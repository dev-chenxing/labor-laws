<!DOCTYPE html><html lang="zh"><head> <meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>广东省劳动保障监察条例</title><link rel="icon" href="/labor-laws/assets/images/favicon_64x64.png" sizes="any"><link rel="stylesheet" href="/labor-laws/assets/css/main.css"></head><body><nav><a href="/labor-laws">劳动保障监察法律法规</a><div class="input" autocomplete="off"><input class="text" type="text" placeholder="查找全部" onInput="searchInput(this.value)"/><span class="icon">🔎</span><div id="search-results"></div></div></nav><header><h1>广东省劳动保障监察条例</h1></header><main><p class="text-center"><strong>第一章  总  则</strong></p><p><a id="1"><strong>第一条</strong></a>   为了保障劳动保障法律、法规和规章的实施，规范劳动保障监察工作，预防和查处违反劳动保障法律、法规或者规章的行为，维护劳动者的合法权益，根据《中华人民共和国劳动法》等劳动保障法律、法规，结合本省实际，制定本条例。</p><p><a id="2"><strong>第二条</strong></a>   本条例适用于对在本省行政区域内的企业、有雇工的个体经济组织、民办非企业单位、基金会、会计师事务所、律师事务所等组织（以下称用人单位）进行劳动保障监察。</p><p>对职业中介机构、职业技能培训机构、职业技能考核鉴定机构、外国企业常驻代表机构和社会保险服务机构进行劳动保障监察，依照本条例执行。</p><p>对国家机关、事业单位、社会团体执行劳动保障法律、法规和规章的情况进行劳动保障监察，由人力资源社会保障行政部门根据其职责，依照本条例执行。</p><p><a id="3"><strong>第三条</strong></a>   劳动保障监察遵循公正、公开、高效、便民的原则。</p><p>实施劳动保障监察，坚持日常巡视检查为主、预防与查处相结合、教育与处罚相结合，接受社会监督。</p><p><a id="4"><strong>第四条</strong></a>   各级人民政府应当加强劳动保障监察工作，建立健全预防和查处劳动保障违法行为的工作机制和维护劳动者权益目标责任制度，对所属的有关部门和下一级人民政府进行考核和监督。</p><p>劳动保障监察所需经费列入本级财政预算。</p><p><a id="5"><strong>第五条</strong></a>   各级人力资源社会保障行政部门主管本行政区域内的劳动保障监察工作。</p><p>公安、司法行政、财政、住房城乡建设、卫生健康、应急管理、国资、市场监督管理、税务等有关部门以及用人单位的主管部门，应当在各自职责范围内协同做好劳动保障监察工作。</p><p><a id="6"><strong>第六条</strong></a>   各级工会依法维护劳动者的合法权益，对用人单位遵守劳动保障法律、法规和规章的情况进行监督；发现用人单位存在劳动保障违法行为的，应当及时向人力资源社会保障行政部门报告；出现重大劳动保障违法事件时，应当到场了解情况，根据职责协助处理。</p><p>人力资源社会保障行政部门在劳动保障监察工作中应当注意听取工会组织的意见和建议；接到工会关于用人单位劳动保障违法行为的报告后，应当按照有关法律、法规的规定及时处理，并将处理结果告知工会。</p><p><a id="7"><strong>第七条</strong></a>   用人单位、劳务派遣用工单位应当遵守劳动保障法律、法规和规章，完善劳动用工管理，接受和配合劳动保障监察。</p><p>企业联合会、工商业联合会等企业方面代表依法引导、帮助用人单位规范用工，配合做好劳动保障监察工作。</p><p><a id="8"><strong>第八条</strong></a>   任何组织或者个人对违反劳动保障法律、法规或者规章的行为，有权向人力资源社会保障行政部门举报。</p><p>劳动者认为用人单位侵犯其劳动保障合法权益的，有权向人力资源社会保障行政部门投诉。</p><p class="text-center"><strong>第二章  劳动保障监察机构和监察员</strong></p><p><a id="9"><strong>第九条</strong></a>   人力资源社会保障行政部门实施劳动保障监察，履行下列职责：</p><p>（一）宣传劳动保障法律、法规和规章，引导、督促用人单位贯彻执行；</p><p>（二）检查用人单位遵守劳动保障法律、法规和规章的情况；</p><p>（三）受理对违反劳动保障法律、法规或者规章的行为的举报、投诉；</p><p>（四）依法纠正和查处违反劳动保障法律、法规或者规章的行为。</p><p>县级以上人力资源社会保障行政部门设立的劳动保障监察机构和人力资源社会保障行政部门依法委托实施劳动保障监察的组织（以下统称劳动保障监察机构）具体负责劳动保障监察工作。</p><p><a id="10"><strong>第十条</strong></a>   各级人民政府应当加强劳动保障监察队伍建设，保障有效、全面履行劳动保障监察职责所需要的场所、装备等条件。</p><p><a id="11"><strong>第十一条</strong></a>   人力资源社会保障行政部门或者劳动保障监察机构中实施劳动保障监察的人员（以下简称劳动保障监察员）进行调查、检查，不得少于两人，并应当佩戴统一的劳动保障监察标志，出示劳动保障监察证件。</p><p>劳动保障监察员在实施劳动保障监察时，应当遵守有关回避的规定。</p><p><a id="12"><strong>第十二条</strong></a>   劳动保障监察员应当忠于职守，秉公执法，勤政廉洁，保守秘密。</p><p>任何组织或者个人对劳动保障监察员的违法违纪行为，有权向人力资源社会保障行政部门或者有关机关检举、控告。</p><p><a id="13"><strong>第十三条</strong></a>   人力资源社会保障行政部门及其劳动保障监察员依法行使劳动保障监察职权受法律保护，任何组织或者个人不得干涉和阻挠。</p><p class="text-center"><strong>第三章  劳动保障监察预警监控</strong></p><p><a id="14"><strong>第十四条</strong></a>   用人单位应当建立以下用工管理台账，真实、准确记录各种用工信息：</p><p>（一）职工名册。包括建立劳动关系的劳动者和被派遣劳动者的姓名、性别、身份证件号码、户籍地址及现住址、联系方式、用工形式、用工起止时间、劳动合同期限、工作岗位等内容。</p><p>（二）录用登记。包括入职登记表、劳动者身份证件复印件等。</p><p>（三）工时台账。包括打卡记录或者考勤表等上下班时间和加班时间的记录。</p><p>（四）工资台账。包括正常工作时间工资、加班工资及其他劳动报酬的发放情况，列明支付日期、支付周期、支付对象姓名、工作时间，以及应发工资项目和数额，代扣、代缴、扣除项目和数额，实发工资数额，银行代发工资凭证或者劳动者签名等内容。</p><p>（五）法律、法规和规章规定的其他台账。</p><p>用工管理台账应当至少保存两年，职工名册、录用登记应当至少保存至劳动者离职后两年。</p><p><a id="15"><strong>第十五条</strong></a>   《广东省高等学校学生实习与毕业生就业见习条例》规定的实习、见习单位接收实习、见习人员的，应当建立以下管理台账：</p><p>（一）实习、见习人员名册。包括姓名、性别、身份证件号码、户籍地址与现住址、联系方式，实习学生所在学校、是否顶岗实习，以及实习、见习的起止时间、工作岗位等内容。</p><p>（二）实习、见习时间台账。包括打卡记录或者考勤表等实习、见习工作时间的记录。</p><p>（三）报酬台账。包括报酬、补助、补贴的发放情况。</p><p>（四）购买意外伤害保险的台账。</p><p>（五）法律、法规和规章规定的其他台账。</p><p>实习、见习人员管理台账应当至少保存至实习、见习结束后两年。</p><p><a id="16"><strong>第十六条</strong></a>   人力资源社会保障行政部门在用人单位设立的劳动保障宣传设施、举报投诉信箱，用人单位应当妥善保护，不得涂污、损毁或者遮盖。</p><p><a id="17"><strong>第十七条</strong></a>   人力资源社会保障行政部门应当建立用人单位用工信息采集制度，建立劳动保障监察信息档案，逐步建立全省统一的劳动保障监察管理系统。</p><p>用人单位应当按照要求通过网络、书面等方式如实提供订立劳动合同、工资支付、工作时间、参加社会保险等相关情况和资料。</p><p>人力资源社会保障行政部门实施劳动保障监察，需要获取用人单位登记注册企业名称、住所、法定代表人姓名、注册资本、经营范围、设立时间等信息的，可以向市场监督管理部门提出查询要求，市场监督管理部门应当及时提供。</p><p><a id="18"><strong>第十八条</strong></a>   人力资源社会保障行政部门应当建立用人单位劳动保障守法诚信档案，实行分级、分类监管。</p><p>对发生重大劳动保障违法行为的用人单位，由人力资源社会保障行政部门向社会公布。公布内容包括用人单位名称、法定代表人（主要责任人）姓名、基本违法事实、处理结果等。</p><p><a id="19"><strong>第十九条</strong></a>   人力资源社会保障行政部门应当对有重大劳动保障违法记录的用人单位实行重点监控，加强日常监管，增加检查频次。</p><p>有关行政部门审查用人单位承接投资、参加政府采购等申请时，应当将用人单位三年内是否存在劳动保障违法记录作为参考。</p><p><a id="20"><strong>第二十条</strong></a>   人力资源社会保障行政部门应当按照规定及时将依法生效法律文书确认的用人单位劳动保障违法信息告知中国人民银行当地分支机构，并由其录入中国人民银行企业信用信息基础数据库。</p><p><a id="21"><strong>第二十一条</strong></a>   县级以上人民政府及其有关部门应当建立健全劳动保障违法行为预警机制。</p><p>县级以上人民政府应当制定劳动保障群体性事件应急预案。对因拖欠或者克扣劳动者工资（以下称欠薪）等劳动保障违法行为引发群体性事件的，人力资源社会保障、公安等部门和工会、企业方面代表应当按照应急预案迅速处理，有关部门应当根据各自职责依法对违法行为给予处罚。</p><p>建筑施工企业因欠薪引发群体性事件的，住房城乡建设部门应当迅速到场协助处理，对涉嫌违法发包、分包、转包、拖欠工程款等违法行为应当依法处理。</p><p class="text-center"><strong>第四章  劳动保障监察的实施</strong></p><p class="text-center"><strong>第一节  一般规定</strong></p><p><a id="22"><strong>第二十二条</strong></a>   劳动保障监察以日常巡视检查、审查用人单位按照要求报送的书面材料、受理举报投诉、开展专项执法检查和网络监察等形式进行。</p><p>人力资源社会保障行政部门应当主动对用人单位开展日常巡视检查，制定年度巡查计划，确定重点检查范围，定期检查用人单位的用工情况。</p><p><a id="23"><strong>第二十三条</strong></a>   人力资源社会保障行政部门依法对下列事项实施劳动保障监察：</p><p>（一）用人单位制定直接涉及劳动者切身利益的规章制度的情况；</p><p>（二）用人单位建立用工管理台账的情况；</p><p>（三）用人单位与劳动者订立劳动合同、约定试用期及其他必备条款、交付劳动合同文本、出具解除或者终止劳动关系证明等情况；</p><p>（四）用人单位执行最低工资标准、支付劳动者工资、经济补偿金及赔偿金的情况；</p><p>（五）用人单位遵守有关就业登记备案的规定，以及遵守台、港、澳人员在内地就业和外国人在中国境内就业规定的情况；</p><p>（六）用人单位遵守女职工、未成年工特殊劳动保护规定和禁止使用童工规定的情况；</p><p>（七）用人单位遵守工作时间和休息休假规定的情况；</p><p>（八）用人单位办理社会保险登记的情况；</p><p>（九）劳务派遣单位、用工单位遵守劳务派遣有关规定的情况；</p><p>（十）外国企业常驻代表机构、涉外就业服务单位遵守有关聘用中国雇员管理规定的情况；</p><p>（十一）职业中介机构、职业技能培训机构和职业技能考核鉴定机构遵守有关职业介绍、职业技能培训和职业技能考核鉴定规定的情况；</p><p>（十二）社会保险服务机构遵守养老、失业、工伤保险相关规定的情况；</p><p>（十三）实习、见习单位遵守有关学生实习、见习劳动保障法律法规的情况；</p><p>（十四）法律、法规和规章规定的其他劳动保障监督检查事项。</p><p><a id="24"><strong>第二十四条</strong></a>   人力资源社会保障行政部门对违反劳动保障法律、法规或者规章的行为作出行政处罚或者行政处理决定前，应当听取用人单位的陈述、申辩；作出行政处罚或者行政处理决定，应当告知用人单位依法享有申请行政复议或者提起行政诉讼的权利。</p><p>法律、法规规定应当依法听证的，应当告知用人单位有权依法要求举行听证；用人单位要求听证的，人力资源社会保障行政部门应当组织听证。</p><p><a id="25"><strong>第二十五条</strong></a>   单位或者个人阻挠劳动保障监察的，公安机关应当按照治安管理处罚有关规定处理。</p><p class="text-center"><strong>第二节  管  辖</strong></p><p><a id="26"><strong>第二十六条</strong></a>   对用人单位的劳动保障监察，由用人单位用工所在地的县级人民政府人力资源社会保障行政部门管辖。具体管辖范围应当向社会公开。</p><p>对依法设立的自由贸易试验区、开发区、产业园区等特定地区用人单位的劳动保障监察，有管辖权的人力资源社会保障行政部门可以依法委托特定地区符合劳动保障监察执法条件的组织实施，法律、法规另有规定的，从其规定。</p><p><a id="27"><strong>第二十七条</strong></a>   对下列情形之一的劳动保障监察，由地级以上市人民政府人力资源社会保障行政部门管辖：</p><p>（一）劳动保障违法行为跨县级行政区域的；</p><p>（二）劳动保障违法行为涉及吊销其核发的许可证的；</p><p>（三）经有权机关批准对市辖区用人单位统一实施劳动保障监察的。</p><p><a id="28"><strong>第二十八条</strong></a>   对下列情形之一的劳动保障监察，由省人民政府人力资源社会保障行政部门管辖：</p><p>（一）劳动保障违法行为跨地级以上市行政区域的；</p><p>（二）劳动保障违法行为涉及吊销其核发的许可证的。</p><p><a id="29"><strong>第二十九条</strong></a>   对社会保险服务机构骗取养老、失业、工伤保险基金支出，以及个人、法人或者其他组织骗取养老、失业、工伤保险待遇的劳动保障监察，由支出基金或者发放待遇的社会保险经办机构所属的人力资源社会保障行政部门管辖。</p><p><a id="30"><strong>第三十条</strong></a>   劳务派遣单位和用工单位在劳务派遣用工中存在劳动保障违法行为的，对一方劳动保障违法行为有管辖权的人力资源社会保障行政部门可以一并处理。</p><p><a id="31"><strong>第三十一条</strong></a>   上级人力资源社会保障行政部门认为必要时，可以查处其行政区域内案情重大的劳动保障违法案件；下级人力资源社会保障行政部门认为案情重大的案件，可以提请上级人力资源社会保障行政部门办理。</p><p>两个或者两个以上的人力资源社会保障行政部门发生管辖争议时，由发生争议的各方协商解决；协商不成的，提请共同的上一级人力资源社会保障行政部门指定管辖。</p><p class="text-center"><strong>第三节  程  序</strong></p><p><a id="32"><strong>第三十二条</strong></a>   人力资源社会保障行政部门发现用人单位可能存在劳动保障违法行为，需要调查处理的，应当在发现之日起五个工作日内立案。</p><p><a id="33"><strong>第三十三条</strong></a>   人力资源社会保障行政部门应当向社会公布举报投诉电话，设置举报投诉信箱和电子信箱，指定人员受理举报投诉。</p><p>人力资源社会保障行政部门对不具有管辖权的举报，应当在接到举报之日起五个工作日内移送有管辖权的人力资源社会保障行政部门。</p><p><a id="34"><strong>第三十四条</strong></a>   以匿名方式向人力资源社会保障行政部门反映用人单位劳动保障违法行为，或者以实名方式反映但不提出维护其具体权益主张的，按照举报处理。</p><p>实名举报人要求反馈处理情况，且有明确、有效的联系方式的，人力资源社会保障行政部门应当将处理情况答复举报人。</p><p><a id="35"><strong>第三十五条</strong></a>   人力资源社会保障行政部门应当为举报人保密；对举报属实，为查处重大违反劳动保障法律、法规或者规章的行为提供主要线索和证据的举报人，给予奖励。</p><p>奖励资金由同级财政列支，具体奖励办法由省人民政府另行制定。</p><p><a id="36"><strong>第三十六条</strong></a>   对符合下列条件的投诉，人力资源社会保障行政部门应当在接到投诉之日起五个工作日内受理，并于受理之日立案查处：</p><p>（一）投诉时间在法律、法规规定的查处期限内；</p><p>（二）有明确的被投诉用人单位；</p><p>（三）投诉人的劳动保障合法权益受到被投诉用人单位的侵害；</p><p>（四）属于劳动保障监察职权范围并由受理投诉的人力资源社会保障行政部门管辖。</p><p>投诉人应当向人力资源社会保障行政部门当面提交本人身份证明、投诉文书和反映劳动关系存在的证明材料。书写投诉文书确有困难的，可以口头投诉，由劳动保障监察机构记录，并由投诉人签名。</p><p><a id="37"><strong>第三十七条</strong></a>   投诉文书应当载明下列事项：</p><p>（一）投诉人的姓名、身份证件号码、法律文书指定送达地址和联系电话；</p><p>（二）被投诉用人单位的名称、住所、联系电话；</p><p>（三）劳动保障合法权益受到侵害的事实和明确、具体的投诉请求。</p><p>投诉文书还可以载明证据和证据来源、证人姓名和联系方式等。</p><p><a id="38"><strong>第三十八条</strong></a>   因同一事由引发十人以上集体投诉的，投诉人可以推选出五名以下代表进行投诉，并向人力资源社会保障行政部门提交投诉人签名或者盖章的推选书。</p><p><a id="39"><strong>第三十九条</strong></a>   人力资源社会保障行政部门应当对以下投诉按照不同情形分别处理：</p><p>（一）不属于劳动保障监察职权范围的，告知投诉人。</p><p>（二）属于劳动保障监察职权范围但不属于受理投诉的人力资源社会保障行政部门管辖的，应当告知投诉人向有管辖权的人力资源社会保障行政部门提出。</p><p>（三）投诉时间超出劳动保障违法行为查处期限的，不予受理。</p><p>（四）已经按照劳动争议处理程序申请仲裁、提起诉讼，或者已经向人民法院申请支付令的，不予受理。但劳动争议仲裁机构或者人民法院裁决认为应当由有关行政部门解决，对其请求事项不予受理或者予以驳回的除外。</p><p>（五）按照法律、法规和规章规定应当通过劳动争议处理程序解决的，不予受理。</p><p>（六）对人力资源社会保障行政部门已经按照劳动保障监察程序作出处理的同一事项重复投诉的，不予受理。</p><p>（七）投诉文书应当载明的事项不明确或者提供材料不齐全的，一次性告知补正；补正后符合规定的，予以受理。</p><p>（八）投诉人通过信函邮寄等形式或者委托他人提交投诉材料，经投诉人本人核实，情况属实并符合受理条件的，予以受理。</p><p>前款规定的告知和不予受理决定应当采用书面形式，并在接到投诉之日起五个工作日内作出；逾期未告知的，自收到投诉材料之日起即为受理。</p><p><a id="40"><strong>第四十条</strong></a>   人力资源社会保障行政部门依法实施劳动保障监察，有权采取下列调查、检查措施：</p><p>（一）进入用人单位的劳动场所实地调查、检查；</p><p>（二）就调查、检查事项询问有关人员；</p><p>（三）要求相关单位或者个人提供与调查、检查事项相关的文件资料或者证据材料，必要时可以发出询问通知书；</p><p>（四）查阅本条例规定的台账等有关资料，采取记录、录音、录像、照像或者复制等方式收集有关情况和资料；</p><p>（五）在证据可能被伪造、变造、损毁、灭失或者事后难以取得的情况下，可以采取证据登记保存措施；</p><p>（六）委托会计师事务所对用人单位工资支付等进行审计；</p><p>（七）委托专门的鉴定机构对专门性问题进行鉴定；</p><p>（八）法律、法规和规章规定的其他调查、检查措施。</p><p>人力资源社会保障行政部门实施调查、检查时，被检查的单位和个人不得拒绝、阻挠调查人员进入劳动场所，应当如实陈述和提供相关资料，并在调查笔录上签名或者盖章；拒绝签名或者盖章的，由调查人员注明拒签事由。</p><p><a id="41"><strong>第四十一条</strong></a>   用人单位发生欠薪，人力资源社会保障行政部门应当依法及时调查处理。</p><p>用人单位发生欠薪，人力资源社会保障行政部门可以采用电话、书面或者张贴公告，以及其他可以确认收悉的方式，通知其法定代表人或者主要负责人接受调查或者配合处理；用人单位法定代表人或者主要负责人无正当理由不接受调查或者配合处理的，人力资源社会保障行政部门可以通过当地新闻媒体或者人力资源社会保障行政部门门户网站，公开用人单位名称、涉嫌欠薪情况、法定代表人或者主要负责人个人基本信息，公告通知其接受调查或者配合处理。</p><p>人力资源社会保障行政部门按照前款规定公告通知后，用人单位法定代表人或者主要负责人仍不接受调查或者配合处理的，按照《广东省工资支付条例》以逃匿方式拖欠工资的有关规定处理。</p><p><a id="42"><strong>第四十二条</strong></a>   人力资源社会保障行政部门对金钱给付等投诉案件，可以依一方当事人申请并经对方同意后，组织双方调解。</p><p>调解达成一致意见并当场全部履行的，人力资源社会保障行政部门视情节轻重依法不予处罚或者减轻对用人单位的处罚。</p><p>调解达成一致意见但未当场全部履行的，当事人双方可以向劳动争议仲裁机构申请审查确认后出具仲裁调解书。人力资源社会保障行政部门视情节轻重依法从轻或者减轻对用人单位的处罚。</p><p><a id="43"><strong>第四十三条</strong></a>   有下列情形之一的，人力资源社会保障行政部门应当终止调解：</p><p>（一）一方当事人拒绝继续调解的；</p><p>（二）经调解无法达成一致意见的；</p><p>（三）人力资源社会保障行政部门认为应当终止调解的其他情形。</p><p>调解终止后，人力资源社会保障行政部门应当继续按照劳动保障监察程序进行处理。</p><p><a id="44"><strong>第四十四条</strong></a>   人力资源社会保障行政部门对违反劳动保障法律、法规或者规章的行为，根据调查、检查的结果，应当自立案之日起四十五个工作日内作出以下处理：</p><p>（一）对依法应当受到行政处罚的，依法作出行政处罚决定；</p><p>（二）对应当改正未改正的，依法责令改正或者作出相应的行政处理决定；</p><p>（三）依法撤销立案。</p><p>对情况复杂的，经人力资源社会保障行政部门负责人批准，可以延长三十个工作日。属于投诉案件的，应当书面通知投诉人。公告、委托审计或者鉴定等期间不计算在办案时限内。</p><p>投诉事项属于未依法支付工资、经济补偿金、赔偿金，经调查查实的证据证明违法行为存在的，应当依法责令改正或者作出相应的行政处理决定。</p><p>对前款规定的投诉事项，人力资源社会保障行政部门已按照本条例第四十条的有关规定充分调查核实，仍无法查实相关事实，双方存在争议的，告知投诉人按照劳动争议处理程序办理。</p><p>发现违法案件不属于劳动保障监察事项的，应当及时移送有关部门处理；存在拒不支付劳动报酬，骗取社会保险基金支出或者社会保险待遇，或者雇用童工从事危重劳动等情形，涉嫌犯罪的，应当依法移送司法机关。</p><p><a id="45"><strong>第四十五条</strong></a>   有下列情形之一的，中止计算监察办案时限：</p><p>（一）依法必须以司法机关、劳动争议仲裁机构或者有关行政部门的结论为依据的，在司法机关、劳动争议仲裁机构或者有关部门尚未作出结论期间；</p><p>（二）投诉人无法联系或者存在其他不可抗拒的事由，致使调查取证无法进行的。</p><p>办案中止由人力资源社会保障行政部门负责人批准，并自批准之日起三个工作日内书面通知投诉人，投诉人无法联系的除外。中止原因消除后，恢复案件办理。</p><p><a id="46"><strong>第四十六条</strong></a>   经立案调查后发现有下列情形之一的，人力资源社会保障行政部门可以撤销立案：</p><p>（一）违法事实不成立的；</p><p>（二）违法行为已经改正，依法可以不予处罚的；</p><p>（三）投诉不符合规定的受理条件但已经立案的；</p><p>（四）投诉案件投诉人撤回投诉的；</p><p>（五）经人力资源社会保障行政部门调解达成一致意见，已当场全部履行或者置换劳动争议仲裁调解书的；</p><p>（六）法律、法规和规章规定的其他情形。</p><p>投诉案件撤销立案的，应当告知投诉人。</p><p><a id="47"><strong>第四十七条</strong></a>   人力资源社会保障行政部门制作出限期整改指令书、行政处理决定书、行政处罚决定书等法律文书后，应当在宣告后当场送达当事人；无法当场送达的，应当在七个工作日内参照民事诉讼的有关规定送达。</p><p>按照规定采取公告方式送达的，应当在受送达人办公场所或者住所张贴，并同时在当地新闻媒体或者人力资源社会保障行政部门门户网站公告，公告期为六十日；但按照本条例第四十一条规定处理的，或者用人单位的欠薪等劳动保障违法行为引发群体性事件的，公告期为三日。</p><p>投诉人指定法律文书送达地址的，人力资源社会保障行政部门可以通过邮政机构向该地址邮寄送达法律文书。</p><p><a id="48"><strong>第四十八条</strong></a>   人力资源社会保障行政部门作出行政处罚、行政处理决定的，应当自决定书发出之日起十日内报送上一级人力资源社会保障行政部门备案。</p><p class="text-center"><strong>第五章  法律责任</strong></p><p><a id="49"><strong>第四十九条</strong></a>   用人单位违反本条例第十四条、第十五条规定，未建立、保存相关台账，或者伪造相关台账的，由人力资源社会保障行政部门责令改正，并可处以二千元以上二万元以下的罚款。</p><p><a id="50"><strong>第五十条</strong></a>   用人单位的规章制度规定了罚款内容，或者其扣减工资的规定没有法律、法规依据的，由人力资源社会保障行政部门责令改正，给予警告。</p><p>用人单位对劳动者实施罚款或者没有法律、法规依据扣减劳动者工资的，由人力资源社会保障行政部门责令限期改正；逾期未改正的，按照被罚款或者扣减工资的人数每人二千元以上五千元以下的标准处以罚款。</p><p><a id="51"><strong>第五十一条</strong></a>   用人单位发生欠薪的，由人力资源社会保障行政部门责令其限期支付；逾期不支付的，责令用人单位按照应付金额百分之五十以上一倍以下的标准向劳动者加付赔偿金。</p><p>用人单位发生欠薪，人力资源社会保障行政部门按照本条例第四十一条第二款规定公告通知后，其法定代表人或者主要负责人仍不接受调查或者配合处理的，由人力资源社会保障行政部门处以一万元以上五万元以下的罚款；引发严重影响公共秩序事件的，由公安机关依法处理；构成犯罪的，依法追究刑事责任。</p><p><a id="52"><strong>第五十二条</strong></a>   用人单位有下列行为之一的，由人力资源社会保障行政部门责令改正，处以二千元以上二万元以下的罚款：</p><p>（一）拒绝、阻挠劳动保障监察员进行调查、检查的；</p><p>（二）无正当理由，拒绝按照劳动保障监察询问通知书要求在指定时间和地点接受调查询问的；</p><p>（三）拒绝提供或者报送用工信息等相关材料的；</p><p>（四）出具伪证、隐匿证据、毁灭证据或者教唆劳动者进行虚假陈述的；</p><p>（五）对人力资源社会保障行政部门采取登记保存措施的证据材料及相关设备擅自处理的。</p><p>违反前款规定，构成违反治安管理行为的，由公安机关依法给予治安管理处罚；构成犯罪的，依法追究刑事责任。</p><p><a id="53"><strong>第五十三条</strong></a>   用人单位违反劳动保障法律、法规或者规章的行为经人力资源社会保障行政部门作出行政处罚决定后，在一年内又发生同类违法行为的，应当依法从重处罚。</p><p><a id="54"><strong>第五十四条</strong></a>   人力资源社会保障行政部门、劳动保障监察机构及其工作人员有下列行为之一的，对直接负责的主管人员和其他直接责任人员，依法给予处分；构成犯罪的，依法追究刑事责任：</p><p>（一）不依法处理举报、投诉，造成严重后果的；</p><p>（二）不按照规定程序调查处理劳动保障监察案件，造成严重后果的；</p><p>（三）对应当予以纠正和处罚的劳动保障违法行为不予纠正、处罚，致使劳动者合法权益遭受损害的；</p><p>（四）泄露被检查单位商业秘密或者举报人有关情况的；</p><p>（五）索取、收受用人单位财物或者谋取其他不正当利益的；</p><p>（六）参与被检查单位安排的有碍公正执法的活动的；</p><p>（七）其他徇私舞弊、滥用职权、玩忽职守的行为。</p><p>人力资源社会保障行政部门、劳动保障监察机构及其工作人员违法行使职权，侵犯用人单位或者劳动者的合法权益的，依法承担赔偿责任。</p><p class="text-center"><strong>第六章  附  则</strong></p><p><a id="55"><strong>第五十五条</strong></a>   对个人、法人或者其他组织骗取社会保险基金支出或者社会保险待遇的行为实施劳动保障监察，依照本条例执行。</p><p><a id="56"><strong>第五十六条</strong></a>   依法应当办理营业执照没有办理或者已被依法吊销营业执照的单位有劳动用工的行为，以及未经许可擅自从事职业中介活动的行为，由人力资源社会保障行政部门依照本条例实施劳动保障监察，并及时通报市场监督管理部门依法查处。</p><p><a id="57"><strong>第五十七条</strong></a>   本条例自2013年5月1日起施行。1996年7月12日广东省第八届人民代表大会常务委员会第二十三次会议通过的《广东省劳动监察条例》同时废止。</p></main><script>const chinese_parseInt = (function(){
	const digits = [
		"0０零○〇洞",
		"1１一壹ㄧ弌么",
		"2２二貳贰弍兩两",
		"3３三參叁弎参叄",
		"4４四肆䦉刀",
		"5５五伍",
		"6６六陸陆",
		"7７七柒拐",
		"8８八捌杯",
		"9９九玖勾"
	];
	const tens = ["十拾什呀", "百佰", "千仟"];
	const exponents = ["萬万", "億亿", "兆", "京經经", "垓", "秭杼", "穰壤", "溝沟", "澗涧", "正", "載", "極"];

	const reDigit = new RegExp("^[" + digits.join("") + "]+$");
	const reTen = new RegExp("(^|[^" + digits.slice(1).join("") + "])[" + tens[0] + "]", "g");

	return str => {
		str = str.toString().replace(/\s+/g, "").replace(reTen, "$1一十");
		// console.log(str);
		let result = 0, buffer = 0, digit = 0, pos;

		let sign = 1;
		if("負负".includes(str.charAt(0))) sign = -1;
		if("正負负".includes(str.charAt(0))) str = str.substring(1);

		if(reDigit.test(str)) {
			for(let c of str)
				result = result * 10 + digits.findIndex(dc => dc.includes(c));
			return result;
		}

		for(let c of str) {
			pos = digits.findIndex(dc => dc.includes(c));
			if(pos !== -1) {
				digit = digit * 10 + pos;
				continue;
			}
			pos = tens.findIndex(tc => tc.includes(c));
			if(pos !== -1) {
				buffer += digit * 10 ** (pos + 1);
				digit = 0;
				continue;
			}
			pos = exponents.findIndex(ec => ec.includes(c));
			if(pos !== -1) {
				buffer += digit;
				if(pos <= 2) result += buffer * 10 ** (4 * (pos + 1));
				else result = BigInt(result) + BigInt(buffer) * 10n ** (4n * (BigInt(pos) + 1n));
				buffer = digit = 0;
				continue;
			}
			return NaN;
		}
		// console.log(result, buffer, digit);
		if(typeof result !== "bigint") {
			result += buffer + digit;
			if(sign === -1) result *= -1;
		}
		else {
			result += BigInt(buffer + digit);
			if(sign === -1) result *= -1n;
		}
		return result;
	};
})();

if(typeof module === 'object') module.exports = chinese_parseInt;
/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/minisearch@7.1.1/dist/umd/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).MiniSearch=e()}(this,(function(){"use strict";function t(t,e,s,i){return new(s||(s=Promise))((function(n,o){function r(t){try{u(i.next(t))}catch(t){o(t)}}function c(t){try{u(i.throw(t))}catch(t){o(t)}}function u(t){var e;t.done?n(t.value):(e=t.value,e instanceof s?e:new s((function(t){t(e)}))).then(r,c)}u((i=i.apply(t,e||[])).next())}))}"function"==typeof SuppressedError&&SuppressedError;const e="KEYS",s="VALUES",i="";class n{constructor(t,e){const s=t._tree,i=Array.from(s.keys());this.set=t,this._type=e,this._path=i.length>0?[{node:s,keys:i}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(0===this._path.length)return{done:!0,value:void 0};const{node:t,keys:e}=o(this._path);if(o(e)===i)return{done:!1,value:this.result()};const s=t.get(o(e));return this._path.push({node:s,keys:Array.from(s.keys())}),this.dive()}backtrack(){if(0===this._path.length)return;const t=o(this._path).keys;t.pop(),t.length>0||(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map((({keys:t})=>o(t))).filter((t=>t!==i)).join("")}value(){return o(this._path).node.get(i)}result(){switch(this._type){case s:return this.value();case e:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const o=t=>t[t.length-1],r=(t,e,s,n,o,c,u,h)=>{const d=c*u;t:for(const a of t.keys())if(a===i){const e=o[d-1];e<=s&&n.set(h,[t.get(a),e])}else{let i=c;for(let t=0;t<a.length;++t,++i){const n=a[t],r=u*i,c=r-u;let h=o[r];const d=Math.max(0,i-s-1),l=Math.min(u-1,i+s);for(let t=d;t<l;++t){const s=n!==e[t],i=o[c+t]+ +s,u=o[c+t+1]+1,d=o[r+t]+1,a=o[r+t+1]=Math.min(i,u,d);a<h&&(h=a)}if(h>s)continue t}r(t.get(a),e,s,n,o,i,u,h+a)}};class c{constructor(t=new Map,e=""){this._size=void 0,this._tree=t,this._prefix=e}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[e,s]=u(this._tree,t.slice(this._prefix.length));if(void 0===e){const[e,n]=m(s);for(const s of e.keys())if(s!==i&&s.startsWith(n)){const i=new Map;return i.set(s.slice(n.length),e.get(s)),new c(i,t)}}return new c(e,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,a(this._tree,t)}entries(){return new n(this,"ENTRIES")}forEach(t){for(const[e,s]of this)t(e,s,this)}fuzzyGet(t,e){return((t,e,s)=>{const i=new Map;if(void 0===e)return i;const n=e.length+1,o=n+s,c=new Uint8Array(o*n).fill(s+1);for(let t=0;t<n;++t)c[t]=t;for(let t=1;t<o;++t)c[t*n]=t;return r(t,e,s,i,c,1,n,""),i})(this._tree,t,e)}get(t){const e=h(this._tree,t);return void 0!==e?e.get(i):void 0}has(t){const e=h(this._tree,t);return void 0!==e&&e.has(i)}keys(){return new n(this,e)}set(t,e){if("string"!=typeof t)throw new Error("key must be a string");this._size=void 0;return d(this._tree,t).set(i,e),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,e){if("string"!=typeof t)throw new Error("key must be a string");this._size=void 0;const s=d(this._tree,t);return s.set(i,e(s.get(i))),this}fetch(t,e){if("string"!=typeof t)throw new Error("key must be a string");this._size=void 0;const s=d(this._tree,t);let n=s.get(i);return void 0===n&&s.set(i,n=e()),n}values(){return new n(this,s)}[Symbol.iterator](){return this.entries()}static from(t){const e=new c;for(const[s,i]of t)e.set(s,i);return e}static fromObject(t){return c.from(Object.entries(t))}}const u=(t,e,s=[])=>{if(0===e.length||null==t)return[t,s];for(const n of t.keys())if(n!==i&&e.startsWith(n))return s.push([t,n]),u(t.get(n),e.slice(n.length),s);return s.push([t,e]),u(void 0,"",s)},h=(t,e)=>{if(0===e.length||null==t)return t;for(const s of t.keys())if(s!==i&&e.startsWith(s))return h(t.get(s),e.slice(s.length))},d=(t,e)=>{const s=e.length;t:for(let n=0;t&&n<s;){for(const o of t.keys())if(o!==i&&e[n]===o[0]){const i=Math.min(s-n,o.length);let r=1;for(;r<i&&e[n+r]===o[r];)++r;const c=t.get(o);if(r===o.length)t=c;else{const s=new Map;s.set(o.slice(r),c),t.set(e.slice(n,n+r),s),t.delete(o),t=s}n+=r;continue t}const o=new Map;return t.set(e.slice(n),o),o}return t},a=(t,e)=>{const[s,n]=u(t,e);if(void 0!==s)if(s.delete(i),0===s.size)l(n);else if(1===s.size){const[t,e]=s.entries().next().value;f(n,t,e)}},l=t=>{if(0===t.length)return;const[e,s]=m(t);if(e.delete(s),0===e.size)l(t.slice(0,-1));else if(1===e.size){const[s,n]=e.entries().next().value;s!==i&&f(t.slice(0,-1),s,n)}},f=(t,e,s)=>{if(0===t.length)return;const[i,n]=m(t);i.set(n+e,s),i.delete(n)},m=t=>t[t.length-1],g="or";class _{constructor(t){if(null==(null==t?void 0:t.fields))throw new Error('MiniSearch: option "fields" must be provided');const e=null==t.autoVacuum||!0===t.autoVacuum?O:t.autoVacuum;this._options=Object.assign(Object.assign(Object.assign({},v),t),{autoVacuum:e,searchOptions:Object.assign(Object.assign({},x),t.searchOptions||{}),autoSuggestOptions:Object.assign(Object.assign({},z),t.autoSuggestOptions||{})}),this._index=new c,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=I,this.addFields(this._options.fields)}add(t){const{extractField:e,tokenize:s,processTerm:i,fields:n,idField:o}=this._options,r=e(t,o);if(null==r)throw new Error(`MiniSearch: document does not have ID field "${o}"`);if(this._idToShortId.has(r))throw new Error(`MiniSearch: duplicate ID ${r}`);const c=this.addDocumentId(r);this.saveStoredFields(c,t);for(const o of n){const n=e(t,o);if(null==n)continue;const r=s(n.toString(),o),u=this._fieldIds[o],h=new Set(r).size;this.addFieldLength(c,u,this._documentCount-1,h);for(const t of r){const e=i(t,o);if(Array.isArray(e))for(const t of e)this.addTerm(u,c,t);else e&&this.addTerm(u,c,e)}}}addAll(t){for(const e of t)this.add(e)}addAllAsync(t,e={}){const{chunkSize:s=10}=e,i={chunk:[],promise:Promise.resolve()},{chunk:n,promise:o}=t.reduce((({chunk:t,promise:e},i,n)=>(t.push(i),(n+1)%s==0?{chunk:[],promise:e.then((()=>new Promise((t=>setTimeout(t,0))))).then((()=>this.addAll(t)))}:{chunk:t,promise:e})),i);return o.then((()=>this.addAll(n)))}remove(t){const{tokenize:e,processTerm:s,extractField:i,fields:n,idField:o}=this._options,r=i(t,o);if(null==r)throw new Error(`MiniSearch: document does not have ID field "${o}"`);const c=this._idToShortId.get(r);if(null==c)throw new Error(`MiniSearch: cannot remove document with ID ${r}: it is not in the index`);for(const o of n){const n=i(t,o);if(null==n)continue;const r=e(n.toString(),o),u=this._fieldIds[o],h=new Set(r).size;this.removeFieldLength(c,u,this._documentCount,h);for(const t of r){const e=s(t,o);if(Array.isArray(e))for(const t of e)this.removeTerm(u,c,t);else e&&this.removeTerm(u,c,e)}}this._storedFields.delete(c),this._documentIds.delete(c),this._idToShortId.delete(r),this._fieldLength.delete(c),this._documentCount-=1}removeAll(t){if(t)for(const e of t)this.remove(e);else{if(arguments.length>0)throw new Error("Expected documents to be present. Omit the argument to remove all documents.");this._index=new c,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldLength=new Map,this._avgFieldLength=[],this._storedFields=new Map,this._nextId=0}}discard(t){const e=this._idToShortId.get(t);if(null==e)throw new Error(`MiniSearch: cannot discard document with ID ${t}: it is not in the index`);this._idToShortId.delete(t),this._documentIds.delete(e),this._storedFields.delete(e),(this._fieldLength.get(e)||[]).forEach(((t,s)=>{this.removeFieldLength(e,s,this._documentCount,t)})),this._fieldLength.delete(e),this._documentCount-=1,this._dirtCount+=1,this.maybeAutoVacuum()}maybeAutoVacuum(){if(!1===this._options.autoVacuum)return;const{minDirtFactor:t,minDirtCount:e,batchSize:s,batchWait:i}=this._options.autoVacuum;this.conditionalVacuum({batchSize:s,batchWait:i},{minDirtCount:e,minDirtFactor:t})}discardAll(t){const e=this._options.autoVacuum;try{this._options.autoVacuum=!1;for(const e of t)this.discard(e)}finally{this._options.autoVacuum=e}this.maybeAutoVacuum()}replace(t){const{idField:e,extractField:s}=this._options,i=s(t,e);this.discard(i),this.add(t)}vacuum(t={}){return this.conditionalVacuum(t)}conditionalVacuum(t,e){return this._currentVacuum?(this._enqueuedVacuumConditions=this._enqueuedVacuumConditions&&e,null!=this._enqueuedVacuum||(this._enqueuedVacuum=this._currentVacuum.then((()=>{const e=this._enqueuedVacuumConditions;return this._enqueuedVacuumConditions=I,this.performVacuuming(t,e)}))),this._enqueuedVacuum):!1===this.vacuumConditionsMet(e)?Promise.resolve():(this._currentVacuum=this.performVacuuming(t),this._currentVacuum)}performVacuuming(e,s){return t(this,void 0,void 0,(function*(){const t=this._dirtCount;if(this.vacuumConditionsMet(s)){const s=e.batchSize||S.batchSize,i=e.batchWait||S.batchWait;let n=1;for(const[t,e]of this._index){for(const[t,s]of e)for(const[i]of s)this._documentIds.has(i)||(s.size<=1?e.delete(t):s.delete(i));0===this._index.get(t).size&&this._index.delete(t),n%s==0&&(yield new Promise((t=>setTimeout(t,i)))),n+=1}this._dirtCount-=t}yield null,this._currentVacuum=this._enqueuedVacuum,this._enqueuedVacuum=null}))}vacuumConditionsMet(t){if(null==t)return!0;let{minDirtCount:e,minDirtFactor:s}=t;return e=e||O.minDirtCount,s=s||O.minDirtFactor,this.dirtCount>=e&&this.dirtFactor>=s}get isVacuuming(){return null!=this._currentVacuum}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}has(t){return this._idToShortId.has(t)}getStoredFields(t){const e=this._idToShortId.get(t);if(null!=e)return this._storedFields.get(e)}search(t,e={}){const{searchOptions:s}=this._options,i=Object.assign(Object.assign({},s),e),n=this.executeQuery(t,e),o=[];for(const[t,{score:e,terms:s,match:r}]of n){const n=s.length||1,c={id:this._documentIds.get(t),score:e*n,terms:Object.keys(r),queryTerms:s,match:r};Object.assign(c,this._storedFields.get(t)),(null==i.filter||i.filter(c))&&o.push(c)}return t===_.wildcard&&null==i.boostDocument||o.sort(k),o}autoSuggest(t,e={}){e=Object.assign(Object.assign({},this._options.autoSuggestOptions),e);const s=new Map;for(const{score:i,terms:n}of this.search(t,e)){const t=n.join(" "),e=s.get(t);null!=e?(e.score+=i,e.count+=1):s.set(t,{score:i,terms:n,count:1})}const i=[];for(const[t,{score:e,terms:n,count:o}]of s)i.push({suggestion:t,terms:n,score:e/o});return i.sort(k),i}get documentCount(){return this._documentCount}get termCount(){return this._index.size}static loadJSON(t,e){if(null==e)throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index");return this.loadJS(JSON.parse(t),e)}static loadJSONAsync(e,s){return t(this,void 0,void 0,(function*(){if(null==s)throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index");return this.loadJSAsync(JSON.parse(e),s)}))}static getDefault(t){if(v.hasOwnProperty(t))return p(v,t);throw new Error(`MiniSearch: unknown option "${t}"`)}static loadJS(t,e){const{index:s,documentIds:i,fieldLength:n,storedFields:o,serializationVersion:r}=t,c=this.instantiateMiniSearch(t,e);c._documentIds=j(i),c._fieldLength=j(n),c._storedFields=j(o);for(const[t,e]of c._documentIds)c._idToShortId.set(e,t);for(const[t,e]of s){const s=new Map;for(const t of Object.keys(e)){let i=e[t];1===r&&(i=i.ds),s.set(parseInt(t,10),j(i))}c._index.set(t,s)}return c}static loadJSAsync(e,s){return t(this,void 0,void 0,(function*(){const{index:t,documentIds:i,fieldLength:n,storedFields:o,serializationVersion:r}=e,c=this.instantiateMiniSearch(e,s);c._documentIds=yield V(i),c._fieldLength=yield V(n),c._storedFields=yield V(o);for(const[t,e]of c._documentIds)c._idToShortId.set(e,t);let u=0;for(const[e,s]of t){const t=new Map;for(const e of Object.keys(s)){let i=s[e];1===r&&(i=i.ds),t.set(parseInt(e,10),yield V(i))}++u%1e3==0&&(yield T(0)),c._index.set(e,t)}return c}))}static instantiateMiniSearch(t,e){const{documentCount:s,nextId:i,fieldIds:n,averageFieldLength:o,dirtCount:r,serializationVersion:u}=t;if(1!==u&&2!==u)throw new Error("MiniSearch: cannot deserialize an index created with an incompatible version");const h=new _(e);return h._documentCount=s,h._nextId=i,h._idToShortId=new Map,h._fieldIds=n,h._avgFieldLength=o,h._dirtCount=r||0,h._index=new c,h}executeQuery(t,e={}){if(t===_.wildcard)return this.executeWildcardQuery(e);if("string"!=typeof t){const s=Object.assign(Object.assign(Object.assign({},e),t),{queries:void 0}),i=t.queries.map((t=>this.executeQuery(t,s)));return this.combineResults(i,s.combineWith)}const{tokenize:s,processTerm:i,searchOptions:n}=this._options,o=Object.assign(Object.assign({tokenize:s,processTerm:i},n),e),{tokenize:r,processTerm:c}=o,u=r(t).flatMap((t=>c(t))).filter((t=>!!t)).map(b(o)).map((t=>this.executeQuerySpec(t,o)));return this.combineResults(u,o.combineWith)}executeQuerySpec(t,e){const s=Object.assign(Object.assign({},this._options.searchOptions),e),i=(s.fields||this._options.fields).reduce(((t,e)=>Object.assign(Object.assign({},t),{[e]:p(s.boost,e)||1})),{}),{boostDocument:n,weights:o,maxFuzzy:r,bm25:c}=s,{fuzzy:u,prefix:h}=Object.assign(Object.assign({},x.weights),o),d=this._index.get(t.term),a=this.termResults(t.term,t.term,1,t.termBoost,d,i,n,c);let l,f;if(t.prefix&&(l=this._index.atPrefix(t.term)),t.fuzzy){const e=!0===t.fuzzy?.2:t.fuzzy,s=e<1?Math.min(r,Math.round(t.term.length*e)):e;s&&(f=this._index.fuzzyGet(t.term,s))}if(l)for(const[e,s]of l){const o=e.length-t.term.length;if(!o)continue;null==f||f.delete(e);const r=h*e.length/(e.length+.3*o);this.termResults(t.term,e,r,t.termBoost,s,i,n,c,a)}if(f)for(const e of f.keys()){const[s,o]=f.get(e);if(!o)continue;const r=u*e.length/(e.length+o);this.termResults(t.term,e,r,t.termBoost,s,i,n,c,a)}return a}executeWildcardQuery(t){const e=new Map,s=Object.assign(Object.assign({},this._options.searchOptions),t);for(const[t,i]of this._documentIds){const n=s.boostDocument?s.boostDocument(i,"",this._storedFields.get(t)):1;e.set(t,{score:n,terms:[],match:{}})}return e}combineResults(t,e=g){if(0===t.length)return new Map;const s=e.toLowerCase(),i=y[s];if(!i)throw new Error(`Invalid combination operator: ${e}`);return t.reduce(i)||new Map}toJSON(){const t=[];for(const[e,s]of this._index){const i={};for(const[t,e]of s)i[t]=Object.fromEntries(e);t.push([e,i])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}termResults(t,e,s,i,n,o,r,c,u=new Map){if(null==n)return u;for(const h of Object.keys(o)){const d=o[h],a=this._fieldIds[h],l=n.get(a);if(null==l)continue;let f=l.size;const m=this._avgFieldLength[a];for(const n of l.keys()){if(!this._documentIds.has(n)){this.removeTerm(a,n,e),f-=1;continue}const o=r?r(this._documentIds.get(n),e,this._storedFields.get(n)):1;if(!o)continue;const g=l.get(n),_=this._fieldLength.get(n)[a],y=s*i*d*o*w(g,f,this._documentCount,_,m,c),b=u.get(n);if(b){b.score+=y,F(b.terms,t);const s=p(b.match,e);s?s.push(h):b.match[e]=[h]}else u.set(n,{score:y,terms:[t],match:{[e]:[h]}})}}return u}addTerm(t,e,s){const i=this._index.fetch(s,C);let n=i.get(t);if(null==n)n=new Map,n.set(e,1),i.set(t,n);else{const t=n.get(e);n.set(e,(t||0)+1)}}removeTerm(t,e,s){if(!this._index.has(s))return void this.warnDocumentChanged(e,t,s);const i=this._index.fetch(s,C),n=i.get(t);null==n||null==n.get(e)?this.warnDocumentChanged(e,t,s):n.get(e)<=1?n.size<=1?i.delete(t):n.delete(e):n.set(e,n.get(e)-1),0===this._index.get(s).size&&this._index.delete(s)}warnDocumentChanged(t,e,s){for(const i of Object.keys(this._fieldIds))if(this._fieldIds[i]===e)return void this._options.logger("warn",`MiniSearch: document with ID ${this._documentIds.get(t)} has changed before removal: term "${s}" was not present in field "${i}". Removing a document after it has changed can corrupt the index!`,"version_conflict")}addDocumentId(t){const e=this._nextId;return this._idToShortId.set(t,e),this._documentIds.set(e,t),this._documentCount+=1,this._nextId+=1,e}addFields(t){for(let e=0;e<t.length;e++)this._fieldIds[t[e]]=e}addFieldLength(t,e,s,i){let n=this._fieldLength.get(t);null==n&&this._fieldLength.set(t,n=[]),n[e]=i;const o=(this._avgFieldLength[e]||0)*s+i;this._avgFieldLength[e]=o/(s+1)}removeFieldLength(t,e,s,i){if(1===s)return void(this._avgFieldLength[e]=0);const n=this._avgFieldLength[e]*s-i;this._avgFieldLength[e]=n/(s-1)}saveStoredFields(t,e){const{storeFields:s,extractField:i}=this._options;if(null==s||0===s.length)return;let n=this._storedFields.get(t);null==n&&this._storedFields.set(t,n={});for(const t of s){const s=i(e,t);void 0!==s&&(n[t]=s)}}}_.wildcard=Symbol("*");const p=(t,e)=>Object.prototype.hasOwnProperty.call(t,e)?t[e]:void 0,y={[g]:(t,e)=>{for(const s of e.keys()){const i=t.get(s);if(null==i)t.set(s,e.get(s));else{const{score:t,terms:n,match:o}=e.get(s);i.score=i.score+t,i.match=Object.assign(i.match,o),M(i.terms,n)}}return t},and:(t,e)=>{const s=new Map;for(const i of e.keys()){const n=t.get(i);if(null==n)continue;const{score:o,terms:r,match:c}=e.get(i);M(n.terms,r),s.set(i,{score:n.score+o,terms:n.terms,match:Object.assign(n.match,c)})}return s},and_not:(t,e)=>{for(const s of e.keys())t.delete(s);return t}},w=(t,e,s,i,n,o)=>{const{k:r,b:c,d:u}=o;return Math.log(1+(s-e+.5)/(e+.5))*(u+t*(r+1)/(t+r*(1-c+c*i/n)))},b=t=>(e,s,i)=>({term:e,fuzzy:"function"==typeof t.fuzzy?t.fuzzy(e,s,i):t.fuzzy||!1,prefix:"function"==typeof t.prefix?t.prefix(e,s,i):!0===t.prefix,termBoost:"function"==typeof t.boostTerm?t.boostTerm(e,s,i):1}),v={idField:"id",extractField:(t,e)=>t[e],tokenize:t=>t.split(L),processTerm:t=>t.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(t,e)=>{"function"==typeof(null===console||void 0===console?void 0:console[t])&&console[t](e)},autoVacuum:!0},x={combineWith:g,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:{k:1.2,b:.7,d:.5}},z={combineWith:"and",prefix:(t,e,s)=>e===s.length-1},S={batchSize:1e3,batchWait:10},I={minDirtFactor:.1,minDirtCount:20},O=Object.assign(Object.assign({},S),I),F=(t,e)=>{t.includes(e)||t.push(e)},M=(t,e)=>{for(const s of e)t.includes(s)||t.push(s)},k=({score:t},{score:e})=>e-t,C=()=>new Map,j=t=>{const e=new Map;for(const s of Object.keys(t))e.set(parseInt(s,10),t[s]);return e},V=e=>t(void 0,void 0,void 0,(function*(){const t=new Map;let s=0;for(const i of Object.keys(e))t.set(parseInt(i,10),e[i]),++s%1e3==0&&(yield T(0));return t})),T=t=>new Promise((e=>setTimeout(e,t))),L=/[\n\r\p{Z}\p{P}]+/u;return _}));
//# sourceMappingURL=/sm/0f05ede3003a11c0848176daa6dae791d4aa6c5c93da9e99ae929f75084ce0d0.map
const baseUrl = "/labor-laws";

const segmenter = Intl.Segmenter && new Intl.Segmenter("zh", { granularity: "word" });
let miniSearch = new MiniSearch({
	fields: ["content"],
	storeFields: ["shorthand", "content", "id"],
	processTerm: (term) => {
		if (!segmenter) return term;
		const tokens = [];
		for (const seg of segmenter.segment(term)) {
			tokens.push(seg.segment);
		}
		return tokens;
	},
});

const indexes = {};
fetch(`${baseUrl}/js/laws.json`)
	.then((res) => res.json())
	.then(function (data) {
		const laws = Object.keys(data);
		miniSearch.addAll(laws.map((law) => {
			return { shorthand: law, ...data[law] };
		}));
		laws.forEach((law)=> {
			const content = [];
			data[law].content.split("\n").forEach((line) => {
				line = line.trim();
				const index = line.search(/\s/);
				if (index > 0) {
					const label = line.slice(0, index);
					if (/条$/.test(label)) {
						content.push([label,line.slice(index).trim()]);
					}
				}
			});
			indexes[law] = content;
		})
	});

function getMatchIndex(elem, match){
	let m = match;
	let matchIndex = -1;
	let numOfRule = -1;
	let label = false;
	const content = indexes[elem.shorthand];
	for (i in content){
		matchIndex = content[i][0].indexOf(m);
		if (matchIndex != -1) {
			numOfRule = i;
			label = true;
			break;
		}
		matchIndex = content[i][1].indexOf(m);
		if (matchIndex != -1) {
			numOfRule = i;
			break;
		}
	}
	if (matchIndex == -1) {
		m = elem.queryTerms[0];
		for (i in content){
			matchIndex = content[i][0].indexOf(m);
			if (matchIndex != -1) {
				numOfRule = i;
				label = true;
				break;
			}
			matchIndex = content[i][1].indexOf(m);
			if (matchIndex != -1) {
				numOfRule = i;
				break;
			}
		}
	}
	return [m, numOfRule, matchIndex, label];
}

function getMatchSnippet(elem, m) {
	const maxLength = 60;
	const [match, numOfRule, matchIndex, isLabel] = getMatchIndex(elem, m);
	let leftText, middleText, rightText;
	if (numOfRule === -1){
		const start = Math.max(0, matchIndex - (maxLength - match.length) / 2);
		const end = Math.min(elem.content.length, matchIndex + match.length + (maxLength - match.length) / 2);
		leftText = elem.content.slice(start, matchIndex);
		middleText = match;
		rightText = elem.content.slice(matchIndex + match.length, end);
	} else {
		if (isLabel){
			const line = indexes[elem.shorthand][numOfRule][1];
			const end = Math.min(line.length, maxLength);
			leftText = line.slice(0, end);
			middleText = "";
			rightText = "";
		} else{
			const line = indexes[elem.shorthand][numOfRule][1];
			const start = Math.max(0, matchIndex - (maxLength - match.length) / 2);
			const end = Math.min(line.length, matchIndex + match.length + (maxLength - match.length) / 2);
			leftText = line.slice(start, matchIndex);
			middleText = match;
			rightText = line.slice(matchIndex + match.length, end);
		}

	}


	const result = document.createElement("a");
	result.className = "search-result";
	result.href = `${baseUrl}/content/${elem.id}.html#${numOfRule}`;

	const label = document.createElement("b");
	label.style.paddingRight = "1rem";
	label.innerHTML = elem.shorthand;
	result.appendChild(label);

	const sublabel = document.createElement("b");
	sublabel.style.paddingRight = "1rem";
	sublabel.innerHTML = indexes[elem.shorthand][numOfRule][0];
	result.appendChild(sublabel);

	const left = document.createElement("span");
	left.innerHTML = leftText
	result.appendChild(left);
	const middle = document.createElement("b");
	middle.innerHTML = middleText;
	result.appendChild(middle);
	const right = document.createElement("span");
	right.innerHTML = rightText;
	result.appendChild(right);

	return result;
}

let searchInput = (val) => {
	const output = document.getElementById("search-results");
	if (val.length >= 2) {
		output.innerHTML = "";
		res = miniSearch.search(val, { prefix: true });
		if (res.length > 0) {
			output.style.display = "block";
			for (elem of res) {
				const snippet = getMatchSnippet(elem, val);
				if (snippet) output.appendChild(snippet);
			}
		} else {
			output.style.display = "none";
			output.innerHTML = "";
		}
	} else {
		output.style.display = "none";
		output.innerHTML = "";
	}
};
</script></body></html>