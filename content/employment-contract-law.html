<!DOCTYPE html><html lang="zh"><head> <meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>中国人民共和国劳动合同法</title><link rel="icon" href="/labor-laws/assets/images/favicon_64x64.png" sizes="any"><link rel="stylesheet" href="/labor-laws/assets/css/main.css"></head><body><nav><a href="/labor-laws">劳动保障监察法律法规</a><div class="input" autocomplete="off"><input class="text" type="text" placeholder="查找全部" onInput="searchInput(this.value)"/><span class="icon">🔎</span><div id="search-results"></div></div></nav><header><h1>中国人民共和国劳动合同法</h1></header><main><p>（2007年6月29日第十届全国人民代表大会常务委员会第二十八次会议通过　根据2012年12月28日第十一届全国人民代表大会常务委员会第三十次会议《关于修改<中华人民共和国劳动合同法>的决定》修正）</p><p class="text-center"><strong>第一章　总则</strong></p><p><a id="1"><strong>第一条</strong></a> 　为了完善劳动合同制度，明确劳动合同双方当事人的权利和义务，保护劳动者的合法权益，构建和发展和谐稳定的劳动关系，制定本法。</p><p><a id="2"><strong>第二条</strong></a> 　中华人民共和国境内的企业、个体经济组织、民办非企业单位等组织（以下称用人单位）与劳动者建立劳动关系，订立、履行、变更、解除或者终止劳动合同，适用本法。</p><p>国家机关、事业单位、社会团体和与其建立劳动关系的劳动者，订立、履行、变更、解除或者终止劳动合同，依照本法执行。</p><p><a id="3"><strong>第三条</strong></a> 　订立劳动合同，应当遵循合法、公平、平等自愿、协商一致、诚实信用的原则。</p><p>依法订立的劳动合同具有约束力，用人单位与劳动者应当履行劳动合同约定的义务。</p><p><a id="4"><strong>第四条</strong></a> 　用人单位应当依法建立和完善劳动规章制度，保障劳动者享有劳动权利、履行劳动义务。</p><p>用人单位在制定、修改或者决定有关劳动报酬、工作时间、休息休假、劳动安全卫生、保险福利、职工培训、劳动纪律以及劳动定额管理等直接涉及劳动者切身利益的规章制度或者重大事项时，应当经职工代表大会或者全体职工讨论，提出方案和意见，与工会或者职工代表平等协商确定。</p><p>在规章制度和重大事项决定实施过程中，工会或者职工认为不适当的，有权向用人单位提出，通过协商予以修改完善。</p><p>用人单位应当将直接涉及劳动者切身利益的规章制度和重大事项决定公示，或者告知劳动者。</p><p><a id="5"><strong>第五条</strong></a> 　县级以上人民政府劳动行政部门会同工会和企业方面代表，建立健全协调劳动关系三方机制，共同研究解决有关劳动关系的重大问题。</p><p><a id="6"><strong>第六条</strong></a> 　工会应当帮助、指导劳动者与用人单位依法订立和履行劳动合同，并与用人单位建立集体协商机制，维护劳动者的合法权益。</p><p></p><p class="text-center"><strong>第二章　劳动合同的订立</strong></p><p></p><p></p><p><a id="7"><strong>第七条</strong></a> 　用人单位自用工之日起即与劳动者建立劳动关系。用人单位应当建立职工名册备查。</p><p><a id="8"><strong>第八条</strong></a> 　用人单位招用劳动者时，应当如实告知劳动者工作内容、工作条件、工作地点、职业危害、安全生产状况、劳动报酬，以及劳动者要求了解的其他情况；用人单位有权了解劳动者与劳动合同直接相关的基本情况，劳动者应当如实说明。</p><p><a id="9"><strong>第九条</strong></a> 　用人单位招用劳动者，不得扣押劳动者的居民身份证和其他证件，不得要求劳动者提供担保或者以其他名义向劳动者收取财物。</p><p><a id="10"><strong>第十条</strong></a> 　建立劳动关系，应当订立书面劳动合同。</p><p>已建立劳动关系，未同时订立书面劳动合同的，应当自用工之日起一个月内订立书面劳动合同。</p><p>用人单位与劳动者在用工前订立劳动合同的，劳动关系自用工之日起建立。</p><p><a id="11"><strong>第十一条</strong></a> 　用人单位未在用工的同时订立书面劳动合同，与劳动者约定的劳动报酬不明确的，新招用的劳动者的劳动报酬按照集体合同规定的标准执行；没有集体合同或者集体合同未规定的，实行同工同酬。</p><p><a id="12"><strong>第十二条</strong></a> 　劳动合同分为固定期限劳动合同、无固定期限劳动合同和以完成一定工作任务为期限的劳动合同。</p><p><a id="13"><strong>第十三条</strong></a> 　固定期限劳动合同，是指用人单位与劳动者约定合同终止时间的劳动合同。</p><p>用人单位与劳动者协商一致，可以订立固定期限劳动合同。</p><p><a id="14"><strong>第十四条</strong></a> 　无固定期限劳动合同，是指用人单位与劳动者约定无确定终止时间的劳动合同。</p><p>用人单位与劳动者协商一致，可以订立无固定期限劳动合同。有下列情形之一，劳动者提出或者同意续订、订立劳动合同的，除劳动者提出订立固定期限劳动合同外，应当订立无固定期限劳动合同:</p><p>（一）劳动者在该用人单位连续工作满十年的；</p><p>（二）用人单位初次实行劳动合同制度或者国有企业改制重新订立劳动合同时，劳动者在该用人单位连续工作满十年且距法定退休年龄不足十年的；</p><p>（三）连续订立二次固定期限劳动合同，且劳动者没有本法第三十九条和第四十条第一项、第二项规定的情形，续订劳动合同的。</p><p>用人单位自用工之日起满一年不与劳动者订立书面劳动合同的，视为用人单位与劳动者已订立无固定期限劳动合同。</p><p><a id="15"><strong>第十五条</strong></a> 　以完成一定工作任务为期限的劳动合同，是指用人单位与劳动者约定以某项工作的完成为合同期限的劳动合同。</p><p>用人单位与劳动者协商一致，可以订立以完成一定工作任务为期限的劳动合同。</p><p><a id="16"><strong>第十六条</strong></a> 　劳动合同由用人单位与劳动者协商一致，并经用人单位与劳动者在劳动合同文本上签字或者盖章生效。</p><p>劳动合同文本由用人单位和劳动者各执一份。</p><p><a id="17"><strong>第十七条</strong></a> 　劳动合同应当具备以下条款:</p><p>（一）用人单位的名称、住所和法定代表人或者主要负责人；</p><p>（二）劳动者的姓名、住址和居民身份证或者其他有效身份证件号码；</p><p>（三）劳动合同期限；</p><p>（四）工作内容和工作地点；</p><p>（五）工作时间和休息休假；</p><p>（六）劳动报酬；</p><p>（七）社会保险；</p><p>（八）劳动保护、劳动条件和职业危害防护；</p><p>（九）法律、法规规定应当纳入劳动合同的其他事项。</p><p>劳动合同除前款规定的必备条款外，用人单位与劳动者可以约定试用期、培训、保守秘密、补充保险和福利待遇等其他事项。</p><p><a id="18"><strong>第十八条</strong></a> 　劳动合同对劳动报酬和劳动条件等标准约定不明确，引发争议的，用人单位与劳动者可以重新协商；协商不成的，适用集体合同规定；没有集体合同或者集体合同未规定劳动报酬的，实行同工同酬；没有集体合同或者集体合同未规定劳动条件等标准的，适用国家有关规定。</p><p><a id="19"><strong>第十九条</strong></a> 　劳动合同期限三个月以上不满一年的，试用期不得超过一个月；劳动合同期限一年以上不满三年的，试用期不得超过二个月；三年以上固定期限和无固定期限的劳动合同，试用期不得超过六个月。</p><p>同一用人单位与同一劳动者只能约定一次试用期。</p><p>以完成一定工作任务为期限的劳动合同或者劳动合同期限不满三个月的，不得约定试用期。</p><p>试用期包含在劳动合同期限内。劳动合同仅约定试用期的，试用期不成立，该期限为劳动合同期限。</p><p><a id="20"><strong>第二十条</strong></a> 　劳动者在试用期的工资不得低于本单位相同岗位最低档工资或者劳动合同约定工资的百分之八十，并不得低于用人单位所在地的最低工资标准。</p><p><a id="21"><strong>第二十一条</strong></a> 　在试用期中，除劳动者有本法第三十九条和第四十条第一项、第二项规定的情形外，用人单位不得解除劳动合同。用人单位在试用期解除劳动合同的，应当向劳动者说明理由。</p><p><a id="22"><strong>第二十二条</strong></a> 　用人单位为劳动者提供专项培训费用，对其进行专业技术培训的，可以与该劳动者订立协议，约定服务期。</p><p>劳动者违反服务期约定的，应当按照约定向用人单位支付违约金。违约金的数额不得超过用人单位提供的培训费用。用人单位要求劳动者支付的违约金不得超过服务期尚未履行部分所应分摊的培训费用。</p><p>用人单位与劳动者约定服务期的，不影响按照正常的工资调整机制提高劳动者在服务期期间的劳动报酬。</p><p><a id="23"><strong>第二十三条</strong></a> 　用人单位与劳动者可以在劳动合同中约定保守用人单位的商业秘密和与知识产权相关的保密事项。</p><p>对负有保密义务的劳动者，用人单位可以在劳动合同或者保密协议中与劳动者约定竞业限制条款，并约定在解除或者终止劳动合同后，在竞业限制期限内按月给予劳动者经济补偿。劳动者违反竞业限制约定的，应当按照约定向用人单位支付违约金。</p><p><a id="24"><strong>第二十四条</strong></a> 　竞业限制的人员限于用人单位的高级管理人员、高级技术人员和其他负有保密义务的人员。竞业限制的范围、地域、期限由用人单位与劳动者约定，竞业限制的约定不得违反法律、法规的规定。</p><p>在解除或者终止劳动合同后，前款规定的人员到与本单位生产或者经营同类产品、从事同类业务的有竞争关系的其他用人单位，或者自己开业生产或者经营同类产品、从事同类业务的竞业限制期限，不得超过二年。</p><p><a id="25"><strong>第二十五条</strong></a> 　除本法第二十二条和第二十三条规定的情形外，用人单位不得与劳动者约定由劳动者承担违约金。</p><p><a id="26"><strong>第二十六条</strong></a> 　下列劳动合同无效或者部分无效:</p><p>（一）以欺诈、胁迫的手段或者乘人之危，使对方在违背真实意思的情况下订立或者变更劳动合同的；</p><p>（二）用人单位免除自己的法定责任、排除劳动者权利的；</p><p>（三）违反法律、行政法规强制性规定的。</p><p>对劳动合同的无效或者部分无效有争议的，由劳动争议仲裁机构或者人民法院确认。</p><p><a id="27"><strong>第二十七条</strong></a> 　劳动合同部分无效，不影响其他部分效力的，其他部分仍然有效。</p><p><a id="28"><strong>第二十八条</strong></a> 　劳动合同被确认无效，劳动者已付出劳动的，用人单位应当向劳动者支付劳动报酬。劳动报酬的数额，参照本单位相同或者相近岗位劳动者的劳动报酬确定。</p><p></p><p class="text-center"><strong>第三章　劳动合同的履行和变更</strong></p><p></p><p></p><p><a id="29"><strong>第二十九条</strong></a> 　用人单位与劳动者应当按照劳动合同的约定，全面履行各自的义务。</p><p><a id="30"><strong>第三十条</strong></a> 　用人单位应当按照劳动合同约定和国家规定，向劳动者及时足额支付劳动报酬。</p><p>用人单位拖欠或者未足额支付劳动报酬的，劳动者可以依法向当地人民法院申请支付令，人民法院应当依法发出支付令。</p><p><a id="31"><strong>第三十一条</strong></a> 　用人单位应当严格执行劳动定额标准，不得强迫或者变相强迫劳动者加班。用人单位安排加班的，应当按照国家有关规定向劳动者支付加班费。</p><p><a id="32"><strong>第三十二条</strong></a> 　劳动者拒绝用人单位管理人员违章指挥、强令冒险作业的，不视为违反劳动合同。</p><p>劳动者对危害生命安全和身体健康的劳动条件，有权对用人单位提出批评、检举和控告。</p><p><a id="33"><strong>第三十三条</strong></a> 　用人单位变更名称、法定代表人、主要负责人或者投资人等事项，不影响劳动合同的履行。</p><p><a id="34"><strong>第三十四条</strong></a> 　用人单位发生合并或者分立等情况，原劳动合同继续有效，劳动合同由承继其权利和义务的用人单位继续履行。</p><p><a id="35"><strong>第三十五条</strong></a> 　用人单位与劳动者协商一致，可以变更劳动合同约定的内容。变更劳动合同，应当采用书面形式。</p><p>变更后的劳动合同文本由用人单位和劳动者各执一份。</p><p></p><p class="text-center"><strong>第四章　劳动合同的解除和终止</strong></p><p></p><p></p><p><a id="36"><strong>第三十六条</strong></a> 　用人单位与劳动者协商一致，可以解除劳动合同。</p><p><a id="37"><strong>第三十七条</strong></a> 　劳动者提前三十日以书面形式通知用人单位，可以解除劳动合同。劳动者在试用期内提前三日通知用人单位，可以解除劳动合同。</p><p><a id="38"><strong>第三十八条</strong></a> 　用人单位有下列情形之一的，劳动者可以解除劳动合同:</p><p>（一）未按照劳动合同约定提供劳动保护或者劳动条件的；</p><p>（二）未及时足额支付劳动报酬的；</p><p>（三）未依法为劳动者缴纳社会保险费的；</p><p>（四）用人单位的规章制度违反法律、法规的规定，损害劳动者权益的；</p><p>（五）因本法第二十六条第一款规定的情形致使劳动合同无效的；</p><p>（六）法律、行政法规规定劳动者可以解除劳动合同的其他情形。</p><p>用人单位以暴力、威胁或者非法限制人身自由的手段强迫劳动者劳动的，或者用人单位违章指挥、强令冒险作业危及劳动者人身安全的，劳动者可以立即解除劳动合同，不需事先告知用人单位。</p><p><a id="39"><strong>第三十九条</strong></a> 　劳动者有下列情形之一的，用人单位可以解除劳动合同:</p><p>（一）在试用期间被证明不符合录用条件的；</p><p>（二）严重违反用人单位的规章制度的；</p><p>（三）严重失职，营私舞弊，给用人单位造成重大损害的；</p><p>（四）劳动者同时与其他用人单位建立劳动关系，对完成本单位的工作任务造成严重影响，或者经用人单位提出，拒不改正的；</p><p>（五）因本法第二十六条第一款第一项规定的情形致使劳动合同无效的；</p><p>（六）被依法追究刑事责任的。</p><p><a id="40"><strong>第四十条</strong></a> 　有下列情形之一的，用人单位提前三十日以书面形式通知劳动者本人或者额外支付劳动者一个月工资后，可以解除劳动合同:</p><p>（一）劳动者患病或者非因工负伤，在规定的医疗期满后不能从事原工作，也不能从事由用人单位另行安排的工作的；</p><p>（二）劳动者不能胜任工作，经过培训或者调整工作岗位，仍不能胜任工作的；</p><p>（三）劳动合同订立时所依据的客观情况发生重大变化，致使劳动合同无法履行，经用人单位与劳动者协商，未能就变更劳动合同内容达成协议的。</p><p><a id="41"><strong>第四十一条</strong></a> 　有下列情形之一，需要裁减人员二十人以上或者裁减不足二十人但占企业职工总数百分之十以上的，用人单位提前三十日向工会或者全体职工说明情况，听取工会或者职工的意见后，裁减人员方案经向劳动行政部门报告，可以裁减人员:</p><p>（一）依照企业破产法规定进行重整的；</p><p>（二）生产经营发生严重困难的；</p><p>（三）企业转产、重大技术革新或者经营方式调整，经变更劳动合同后，仍需裁减人员的；</p><p>（四）其他因劳动合同订立时所依据的客观经济情况发生重大变化，致使劳动合同无法履行的。</p><p>裁减人员时，应当优先留用下列人员:</p><p>（一）与本单位订立较长期限的固定期限劳动合同的；</p><p>（二）与本单位订立无固定期限劳动合同的；</p><p>（三）家庭无其他就业人员，有需要扶养的老人或者未成年人的。</p><p>用人单位依照本条第一款规定裁减人员，在六个月内重新招用人员的，应当通知被裁减的人员，并在同等条件下优先招用被裁减的人员。</p><p><a id="42"><strong>第四十二条</strong></a> 　劳动者有下列情形之一的，用人单位不得依照本法第四十条、第四十一条的规定解除劳动合同:</p><p>（一）从事接触职业病危害作业的劳动者未进行离岗前职业健康检查，或者疑似职业病病人在诊断或者医学观察期间的；</p><p>（二）在本单位患职业病或者因工负伤并被确认丧失或者部分丧失劳动能力的；</p><p>（三）患病或者非因工负伤，在规定的医疗期内的；</p><p>（四）女职工在孕期、产期、哺乳期的；</p><p>（五）在本单位连续工作满十五年，且距法定退休年龄不足五年的；</p><p>（六）法律、行政法规规定的其他情形。</p><p><a id="43"><strong>第四十三条</strong></a> 　用人单位单方解除劳动合同，应当事先将理由通知工会。用人单位违反法律、行政法规规定或者劳动合同约定的，工会有权要求用人单位纠正。用人单位应当研究工会的意见，并将处理结果书面通知工会。</p><p><a id="44"><strong>第四十四条</strong></a> 　有下列情形之一的，劳动合同终止:</p><p>（一）劳动合同期满的；</p><p>（二）劳动者开始依法享受基本养老保险待遇的；</p><p>（三）劳动者死亡，或者被人民法院宣告死亡或者宣告失踪的；</p><p>（四）用人单位被依法宣告破产的；</p><p>（五）用人单位被吊销营业执照、责令关闭、撤销或者用人单位决定提前解散的；</p><p>（六）法律、行政法规规定的其他情形。</p><p><a id="45"><strong>第四十五条</strong></a> 　劳动合同期满，有本法第四十二条规定情形之一的，劳动合同应当续延至相应的情形消失时终止。但是，本法第四十二条第二项规定丧失或者部分丧失劳动能力劳动者的劳动合同的终止，按照国家有关工伤保险的规定执行。</p><p><a id="46"><strong>第四十六条</strong></a> 　有下列情形之一的，用人单位应当向劳动者支付经济补偿:</p><p>（一）劳动者依照本法第三十八条规定解除劳动合同的；</p><p>（二）用人单位依照本法第三十六条规定向劳动者提出解除劳动合同并与劳动者协商一致解除劳动合同的；</p><p>（三）用人单位依照本法第四十条规定解除劳动合同的；</p><p>（四）用人单位依照本法第四十一条第一款规定解除劳动合同的；</p><p>（五）除用人单位维持或者提高劳动合同约定条件续订劳动合同，劳动者不同意续订的情形外，依照本法第四十四条第一项规定终止固定期限劳动合同的；</p><p>（六）依照本法第四十四条第四项、第五项规定终止劳动合同的；</p><p>（七）法律、行政法规规定的其他情形。</p><p><a id="47"><strong>第四十七条</strong></a> 　经济补偿按劳动者在本单位工作的年限，每满一年支付一个月工资的标准向劳动者支付。六个月以上不满一年的，按一年计算；不满六个月的，向劳动者支付半个月工资的经济补偿。</p><p>劳动者月工资高于用人单位所在直辖市、设区的市级人民政府公布的本地区上年度职工月平均工资三倍的，向其支付经济补偿的标准按职工月平均工资三倍的数额支付，向其支付经济补偿的年限最高不超过十二年。</p><p>本条所称月工资是指劳动者在劳动合同解除或者终止前十二个月的平均工资。</p><p><a id="48"><strong>第四十八条</strong></a> 　用人单位违反本法规定解除或者终止劳动合同，劳动者要求继续履行劳动合同的，用人单位应当继续履行；劳动者不要求继续履行劳动合同或者劳动合同已经不能继续履行的，用人单位应当依照本法第八十七条规定支付赔偿金。</p><p><a id="49"><strong>第四十九条</strong></a> 　国家采取措施，建立健全劳动者社会保险关系跨地区转移接续制度。</p><p><a id="50"><strong>第五十条</strong></a> 　用人单位应当在解除或者终止劳动合同时出具解除或者终止劳动合同的证明，并在十五日内为劳动者办理档案和社会保险关系转移手续。</p><p>劳动者应当按照双方约定，办理工作交接。用人单位依照本法有关规定应当向劳动者支付经济补偿的，在办结工作交接时支付。</p><p>用人单位对已经解除或者终止的劳动合同的文本，至少保存二年备查。</p><p></p><p class="text-center"><strong>第五章　特别规定</strong></p><p></p><p></p><p class="text-center"><strong>第一节　集体合同</strong></p><p></p><p></p><p><a id="51"><strong>第五十一条</strong></a> 　企业职工一方与用人单位通过平等协商，可以就劳动报酬、工作时间、休息休假、劳动安全卫生、保险福利等事项订立集体合同。集体合同草案应当提交职工代表大会或者全体职工讨论通过。</p><p>集体合同由工会代表企业职工一方与用人单位订立；尚未建立工会的用人单位，由上级工会指导劳动者推举的代表与用人单位订立。</p><p><a id="52"><strong>第五十二条</strong></a> 　企业职工一方与用人单位可以订立劳动安全卫生、女职工权益保护、工资调整机制等专项集体合同。</p><p><a id="53"><strong>第五十三条</strong></a> 　在县级以下区域内，建筑业、采矿业、餐饮服务业等行业可以由工会与企业方面代表订立行业性集体合同，或者订立区域性集体合同。</p><p><a id="54"><strong>第五十四条</strong></a> 　集体合同订立后，应当报送劳动行政部门；劳动行政部门自收到集体合同文本之日起十五日内未提出异议的，集体合同即行生效。</p><p>依法订立的集体合同对用人单位和劳动者具有约束力。行业性、区域性集体合同对当地本行业、本区域的用人单位和劳动者具有约束力。</p><p><a id="55"><strong>第五十五条</strong></a> 　集体合同中劳动报酬和劳动条件等标准不得低于当地人民政府规定的最低标准；用人单位与劳动者订立的劳动合同中劳动报酬和劳动条件等标准不得低于集体合同规定的标准。</p><p><a id="56"><strong>第五十六条</strong></a> 　用人单位违反集体合同，侵犯职工劳动权益的，工会可以依法要求用人单位承担责任；因履行集体合同发生争议，经协商解决不成的，工会可以依法申请仲裁、提起诉讼。</p><p></p><p class="text-center"><strong>第二节　劳务派遣</strong></p><p></p><p></p><p><a id="57"><strong>第五十七条</strong></a> 　经营劳务派遣业务应当具备下列条件:</p><p>（一）注册资本不得少于人民币二百万元；</p><p>（二）有与开展业务相适应的固定的经营场所和设施；</p><p>（三）有符合法律、行政法规规定的劳务派遣管理制度；</p><p>（四）法律、行政法规规定的其他条件。</p><p>经营劳务派遣业务，应当向劳动行政部门依法申请行政许可；经许可的，依法办理相应的公司登记。未经许可，任何单位和个人不得经营劳务派遣业务。</p><p><a id="58"><strong>第五十八条</strong></a> 　劳务派遣单位是本法所称用人单位，应当履行用人单位对劳动者的义务。劳务派遣单位与被派遣劳动者订立的劳动合同，除应当载明本法第十七条规定的事项外，还应当载明被派遣劳动者的用工单位以及派遣期限、工作岗位等情况。</p><p>劳务派遣单位应当与被派遣劳动者订立二年以上的固定期限劳动合同，按月支付劳动报酬；被派遣劳动者在无工作期间，劳务派遣单位应当按照所在地人民政府规定的最低工资标准，向其按月支付报酬。</p><p><a id="59"><strong>第五十九条</strong></a> 　劳务派遣单位派遣劳动者应当与接受以劳务派遣形式用工的单位（以下称用工单位）订立劳务派遣协议。劳务派遣协议应当约定派遣岗位和人员数量、派遣期限、劳动报酬和社会保险费的数额与支付方式以及违反协议的责任。</p><p>用工单位应当根据工作岗位的实际需要与劳务派遣单位确定派遣期限，不得将连续用工期限分割订立数个短期劳务派遣协议。</p><p><a id="60"><strong>第六十条</strong></a> 　劳务派遣单位应当将劳务派遣协议的内容告知被派遣劳动者。</p><p>劳务派遣单位不得克扣用工单位按照劳务派遣协议支付给被派遣劳动者的劳动报酬。</p><p>劳务派遣单位和用工单位不得向被派遣劳动者收取费用。</p><p><a id="61"><strong>第六十一条</strong></a> 　劳务派遣单位跨地区派遣劳动者的，被派遣劳动者享有的劳动报酬和劳动条件，按照用工单位所在地的标准执行。</p><p><a id="62"><strong>第六十二条</strong></a> 　用工单位应当履行下列义务:</p><p>（一）执行国家劳动标准，提供相应的劳动条件和劳动保护；</p><p>（二）告知被派遣劳动者的工作要求和劳动报酬；</p><p>（三）支付加班费、绩效奖金，提供与工作岗位相关的福利待遇；</p><p>（四）对在岗被派遣劳动者进行工作岗位所必需的培训；</p><p>（五）连续用工的，实行正常的工资调整机制。</p><p>用工单位不得将被派遣劳动者再派遣到其他用人单位。</p><p><a id="63"><strong>第六十三条</strong></a> 　被派遣劳动者享有与用工单位的劳动者同工同酬的权利。用工单位应当按照同工同酬原则，对被派遣劳动者与本单位同类岗位的劳动者实行相同的劳动报酬分配办法。用工单位无同类岗位劳动者的，参照用工单位所在地相同或者相近岗位劳动者的劳动报酬确定。</p><p>劳务派遣单位与被派遣劳动者订立的劳动合同和与用工单位订立的劳务派遣协议，载明或者约定的向被派遣劳动者支付的劳动报酬应当符合前款规定。</p><p><a id="64"><strong>第六十四条</strong></a> 　被派遣劳动者有权在劳务派遣单位或者用工单位依法参加或者组织工会，维护自身的合法权益。</p><p><a id="65"><strong>第六十五条</strong></a> 　被派遣劳动者可以依照本法第三十六条、第三十八条的规定与劳务派遣单位解除劳动合同。</p><p>被派遣劳动者有本法第三十九条和第四十条第一项、第二项规定情形的，用工单位可以将劳动者退回劳务派遣单位，劳务派遣单位依照本法有关规定，可以与劳动者解除劳动合同。</p><p><a id="66"><strong>第六十六条</strong></a> 　劳动合同用工是我国的企业基本用工形式。劳务派遣用工是补充形式，只能在临时性、辅助性或者替代性的工作岗位上实施。</p><p>前款规定的临时性工作岗位是指存续时间不超过六个月的岗位；辅助性工作岗位是指为主营业务岗位提供服务的非主营业务岗位；替代性工作岗位是指用工单位的劳动者因脱产学习、休假等原因无法工作的一定期间内，可以由其他劳动者替代工作的岗位。</p><p>用工单位应当严格控制劳务派遣用工数量，不得超过其用工总量的一定比例，具体比例由国务院劳动行政部门规定。</p><p><a id="67"><strong>第六十七条</strong></a> 　用人单位不得设立劳务派遣单位向本单位或者所属单位派遣劳动者。</p><p></p><p class="text-center"><strong>第三节　非全日制用工</strong></p><p></p><p></p><p><a id="68"><strong>第六十八条</strong></a> 　非全日制用工，是指以小时计酬为主，劳动者在同一用人单位一般平均每日工作时间不超过四小时，每周工作时间累计不超过二十四小时的用工形式。</p><p><a id="69"><strong>第六十九条</strong></a> 　非全日制用工双方当事人可以订立口头协议。</p><p>从事非全日制用工的劳动者可以与一个或者一个以上用人单位订立劳动合同；但是，后订立的劳动合同不得影响先订立的劳动合同的履行。</p><p><a id="70"><strong>第七十条</strong></a> 　非全日制用工双方当事人不得约定试用期。</p><p><a id="71"><strong>第七十一条</strong></a> 　非全日制用工双方当事人任何一方都可以随时通知对方终止用工。终止用工，用人单位不向劳动者支付经济补偿。</p><p><a id="72"><strong>第七十二条</strong></a> 　非全日制用工小时计酬标准不得低于用人单位所在地人民政府规定的最低小时工资标准。</p><p>非全日制用工劳动报酬结算支付周期最长不得超过十五日。</p><p></p><p class="text-center"><strong>第六章　监督检查</strong></p><p></p><p></p><p><a id="73"><strong>第七十三条</strong></a> 　国务院劳动行政部门负责全国劳动合同制度实施的监督管理。</p><p>县级以上地方人民政府劳动行政部门负责本行政区域内劳动合同制度实施的监督管理。</p><p>县级以上各级人民政府劳动行政部门在劳动合同制度实施的监督管理工作中，应当听取工会、企业方面代表以及有关行业主管部门的意见。</p><p><a id="74"><strong>第七十四条</strong></a> 　县级以上地方人民政府劳动行政部门依法对下列实施劳动合同制度的情况进行监督检查:</p><p>（一）用人单位制定直接涉及劳动者切身利益的规章制度及其执行的情况；</p><p>（二）用人单位与劳动者订立和解除劳动合同的情况；</p><p>（三）劳务派遣单位和用工单位遵守劳务派遣有关规定的情况；</p><p>（四）用人单位遵守国家关于劳动者工作时间和休息休假规定的情况；</p><p>（五）用人单位支付劳动合同约定的劳动报酬和执行最低工资标准的情况；</p><p>（六）用人单位参加各项社会保险和缴纳社会保险费的情况；</p><p>（七）法律、法规规定的其他劳动监察事项。</p><p><a id="75"><strong>第七十五条</strong></a> 　县级以上地方人民政府劳动行政部门实施监督检查时，有权查阅与劳动合同、集体合同有关的材料，有权对劳动场所进行实地检查，用人单位和劳动者都应当如实提供有关情况和材料。</p><p>劳动行政部门的工作人员进行监督检查，应当出示证件，依法行使职权，文明执法。</p><p><a id="76"><strong>第七十六条</strong></a> 　县级以上人民政府建设、卫生、安全生产监督管理等有关主管部门在各自职责范围内，对用人单位执行劳动合同制度的情况进行监督管理。</p><p><a id="77"><strong>第七十七条</strong></a> 　劳动者合法权益受到侵害的，有权要求有关部门依法处理，或者依法申请仲裁、提起诉讼。</p><p><a id="78"><strong>第七十八条</strong></a> 　工会依法维护劳动者的合法权益，对用人单位履行劳动合同、集体合同的情况进行监督。用人单位违反劳动法律、法规和劳动合同、集体合同的，工会有权提出意见或者要求纠正；劳动者申请仲裁、提起诉讼的，工会依法给予支持和帮助。</p><p><a id="79"><strong>第七十九条</strong></a> 　任何组织或者个人对违反本法的行为都有权举报，县级以上人民政府劳动行政部门应当及时核实、处理，并对举报有功人员给予奖励。</p><p></p><p class="text-center"><strong>第七章　法律责任</strong></p><p></p><p></p><p><a id="80"><strong>第八十条</strong></a> 　用人单位直接涉及劳动者切身利益的规章制度违反法律、法规规定的，由劳动行政部门责令改正，给予警告；给劳动者造成损害的，应当承担赔偿责任。</p><p><a id="81"><strong>第八十一条</strong></a> 　用人单位提供的劳动合同文本未载明本法规定的劳动合同必备条款或者用人单位未将劳动合同文本交付劳动者的，由劳动行政部门责令改正；给劳动者造成损害的，应当承担赔偿责任。</p><p><a id="82"><strong>第八十二条</strong></a> 　用人单位自用工之日起超过一个月不满一年未与劳动者订立书面劳动合同的，应当向劳动者每月支付二倍的工资。</p><p>用人单位违反本法规定不与劳动者订立无固定期限劳动合同的，自应当订立无固定期限劳动合同之日起向劳动者每月支付二倍的工资。</p><p><a id="83"><strong>第八十三条</strong></a> 　用人单位违反本法规定与劳动者约定试用期的，由劳动行政部门责令改正；违法约定的试用期已经履行的，由用人单位以劳动者试用期满月工资为标准，按已经履行的超过法定试用期的期间向劳动者支付赔偿金。</p><p><a id="84"><strong>第八十四条</strong></a> 　用人单位违反本法规定，扣押劳动者居民身份证等证件的，由劳动行政部门责令限期退还劳动者本人，并依照有关法律规定给予处罚。</p><p>用人单位违反本法规定，以担保或者其他名义向劳动者收取财物的，由劳动行政部门责令限期退还劳动者本人，并以每人五百元以上二千元以下的标准处以罚款；给劳动者造成损害的，应当承担赔偿责任。</p><p>劳动者依法解除或者终止劳动合同，用人单位扣押劳动者档案或者其他物品的，依照前款规定处罚。</p><p><a id="85"><strong>第八十五条</strong></a> 　用人单位有下列情形之一的，由劳动行政部门责令限期支付劳动报酬、加班费或者经济补偿；劳动报酬低于当地最低工资标准的，应当支付其差额部分；逾期不支付的，责令用人单位按应付金额百分之五十以上百分之一百以下的标准向劳动者加付赔偿金:</p><p>（一）未按照劳动合同的约定或者国家规定及时足额支付劳动者劳动报酬的；</p><p>（二）低于当地最低工资标准支付劳动者工资的；</p><p>（三）安排加班不支付加班费的；</p><p>（四）解除或者终止劳动合同，未依照本法规定向劳动者支付经济补偿的。</p><p><a id="86"><strong>第八十六条</strong></a> 　劳动合同依照本法第二十六条规定被确认无效，给对方造成损害的，有过错的一方应当承担赔偿责任。</p><p><a id="87"><strong>第八十七条</strong></a> 　用人单位违反本法规定解除或者终止劳动合同的，应当依照本法第四十七条规定的经济补偿标准的二倍向劳动者支付赔偿金。</p><p><a id="88"><strong>第八十八条</strong></a> 　用人单位有下列情形之一的，依法给予行政处罚；构成犯罪的，依法追究刑事责任；给劳动者造成损害的，应当承担赔偿责任:</p><p>（一）以暴力、威胁或者非法限制人身自由的手段强迫劳动的；</p><p>（二）违章指挥或者强令冒险作业危及劳动者人身安全的；</p><p>（三）侮辱、体罚、殴打、非法搜查或者拘禁劳动者的；</p><p>（四）劳动条件恶劣、环境污染严重，给劳动者身心健康造成严重损害的。</p><p><a id="89"><strong>第八十九条</strong></a> 　用人单位违反本法规定未向劳动者出具解除或者终止劳动合同的书面证明，由劳动行政部门责令改正；给劳动者造成损害的，应当承担赔偿责任。</p><p><a id="90"><strong>第九十条</strong></a> 　劳动者违反本法规定解除劳动合同，或者违反劳动合同中约定的保密义务或者竞业限制，给用人单位造成损失的，应当承担赔偿责任。</p><p><a id="91"><strong>第九十一条</strong></a> 　用人单位招用与其他用人单位尚未解除或者终止劳动合同的劳动者，给其他用人单位造成损失的，应当承担连带赔偿责任。</p><p><a id="92"><strong>第九十二条</strong></a> 　违反本法规定，未经许可，擅自经营劳务派遣业务的，由劳动行政部门责令停止违法行为，没收违法所得，并处违法所得一倍以上五倍以下的罚款；没有违法所得的，可以处五万元以下的罚款。</p><p>劳务派遣单位、用工单位违反本法有关劳务派遣规定的，由劳动行政部门责令限期改正；逾期不改正的，以每人五千元以上一万元以下的标准处以罚款，对劳务派遣单位，吊销其劳务派遣业务经营许可证。用工单位给被派遣劳动者造成损害的，劳务派遣单位与用工单位承担连带赔偿责任。</p><p><a id="93"><strong>第九十三条</strong></a> 　对不具备合法经营资格的用人单位的违法犯罪行为，依法追究法律责任；劳动者已经付出劳动的，该单位或者其出资人应当依照本法有关规定向劳动者支付劳动报酬、经济补偿、赔偿金；给劳动者造成损害的，应当承担赔偿责任。</p><p><a id="94"><strong>第九十四条</strong></a> 　个人承包经营违反本法规定招用劳动者，给劳动者造成损害的，发包的组织与个人承包经营者承担连带赔偿责任。</p><p><a id="95"><strong>第九十五条</strong></a> 　劳动行政部门和其他有关主管部门及其工作人员玩忽职守、不履行法定职责，或者违法行使职权，给劳动者或者用人单位造成损害的，应当承担赔偿责任；对直接负责的主管人员和其他直接责任人员，依法给予行政处分；构成犯罪的，依法追究刑事责任。</p><p></p><p class="text-center"><strong>第八章　附则</strong></p><p></p><p></p><p><a id="96"><strong>第九十六条</strong></a> 　事业单位与实行聘用制的工作人员订立、履行、变更、解除或者终止劳动合同，法律、行政法规或者国务院另有规定的，依照其规定；未作规定的，依照本法有关规定执行。</p><p><a id="97"><strong>第九十七条</strong></a> 　本法施行前已依法订立且在本法施行之日存续的劳动合同，继续履行；本法第十四条第二款第三项规定连续订立固定期限劳动合同的次数，自本法施行后续订固定期限劳动合同时开始计算。</p><p>本法施行前已建立劳动关系，尚未订立书面劳动合同的，应当自本法施行之日起一个月内订立。</p><p>本法施行之日存续的劳动合同在本法施行后解除或者终止，依照本法第四十六条规定应当支付经济补偿的，经济补偿年限自本法施行之日起计算；本法施行前按照当时有关规定，用人单位应当向劳动者支付经济补偿的，按照当时有关规定执行。</p><p><a id="98"><strong>第九十八条</strong></a> 　本法自2008年1月1日起施行。</p></main><script>const chinese_parseInt = (function(){
	const digits = [
		"0０零○〇洞",
		"1１一壹ㄧ弌么",
		"2２二貳贰弍兩两",
		"3３三參叁弎参叄",
		"4４四肆䦉刀",
		"5５五伍",
		"6６六陸陆",
		"7７七柒拐",
		"8８八捌杯",
		"9９九玖勾"
	];
	const tens = ["十拾什呀", "百佰", "千仟"];
	const exponents = ["萬万", "億亿", "兆", "京經经", "垓", "秭杼", "穰壤", "溝沟", "澗涧", "正", "載", "極"];

	const reDigit = new RegExp("^[" + digits.join("") + "]+$");
	const reTen = new RegExp("(^|[^" + digits.slice(1).join("") + "])[" + tens[0] + "]", "g");

	return str => {
		str = str.toString().replace(/\s+/g, "").replace(reTen, "$1一十");
		// console.log(str);
		let result = 0, buffer = 0, digit = 0, pos;

		let sign = 1;
		if("負负".includes(str.charAt(0))) sign = -1;
		if("正負负".includes(str.charAt(0))) str = str.substring(1);

		if(reDigit.test(str)) {
			for(let c of str)
				result = result * 10 + digits.findIndex(dc => dc.includes(c));
			return result;
		}

		for(let c of str) {
			pos = digits.findIndex(dc => dc.includes(c));
			if(pos !== -1) {
				digit = digit * 10 + pos;
				continue;
			}
			pos = tens.findIndex(tc => tc.includes(c));
			if(pos !== -1) {
				buffer += digit * 10 ** (pos + 1);
				digit = 0;
				continue;
			}
			pos = exponents.findIndex(ec => ec.includes(c));
			if(pos !== -1) {
				buffer += digit;
				if(pos <= 2) result += buffer * 10 ** (4 * (pos + 1));
				else result = BigInt(result) + BigInt(buffer) * 10n ** (4n * (BigInt(pos) + 1n));
				buffer = digit = 0;
				continue;
			}
			return NaN;
		}
		// console.log(result, buffer, digit);
		if(typeof result !== "bigint") {
			result += buffer + digit;
			if(sign === -1) result *= -1;
		}
		else {
			result += BigInt(buffer + digit);
			if(sign === -1) result *= -1n;
		}
		return result;
	};
})();

if(typeof module === 'object') module.exports = chinese_parseInt;
/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/minisearch@7.1.1/dist/umd/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).MiniSearch=e()}(this,(function(){"use strict";function t(t,e,s,i){return new(s||(s=Promise))((function(n,o){function r(t){try{u(i.next(t))}catch(t){o(t)}}function c(t){try{u(i.throw(t))}catch(t){o(t)}}function u(t){var e;t.done?n(t.value):(e=t.value,e instanceof s?e:new s((function(t){t(e)}))).then(r,c)}u((i=i.apply(t,e||[])).next())}))}"function"==typeof SuppressedError&&SuppressedError;const e="KEYS",s="VALUES",i="";class n{constructor(t,e){const s=t._tree,i=Array.from(s.keys());this.set=t,this._type=e,this._path=i.length>0?[{node:s,keys:i}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(0===this._path.length)return{done:!0,value:void 0};const{node:t,keys:e}=o(this._path);if(o(e)===i)return{done:!1,value:this.result()};const s=t.get(o(e));return this._path.push({node:s,keys:Array.from(s.keys())}),this.dive()}backtrack(){if(0===this._path.length)return;const t=o(this._path).keys;t.pop(),t.length>0||(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map((({keys:t})=>o(t))).filter((t=>t!==i)).join("")}value(){return o(this._path).node.get(i)}result(){switch(this._type){case s:return this.value();case e:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const o=t=>t[t.length-1],r=(t,e,s,n,o,c,u,h)=>{const d=c*u;t:for(const a of t.keys())if(a===i){const e=o[d-1];e<=s&&n.set(h,[t.get(a),e])}else{let i=c;for(let t=0;t<a.length;++t,++i){const n=a[t],r=u*i,c=r-u;let h=o[r];const d=Math.max(0,i-s-1),l=Math.min(u-1,i+s);for(let t=d;t<l;++t){const s=n!==e[t],i=o[c+t]+ +s,u=o[c+t+1]+1,d=o[r+t]+1,a=o[r+t+1]=Math.min(i,u,d);a<h&&(h=a)}if(h>s)continue t}r(t.get(a),e,s,n,o,i,u,h+a)}};class c{constructor(t=new Map,e=""){this._size=void 0,this._tree=t,this._prefix=e}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[e,s]=u(this._tree,t.slice(this._prefix.length));if(void 0===e){const[e,n]=m(s);for(const s of e.keys())if(s!==i&&s.startsWith(n)){const i=new Map;return i.set(s.slice(n.length),e.get(s)),new c(i,t)}}return new c(e,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,a(this._tree,t)}entries(){return new n(this,"ENTRIES")}forEach(t){for(const[e,s]of this)t(e,s,this)}fuzzyGet(t,e){return((t,e,s)=>{const i=new Map;if(void 0===e)return i;const n=e.length+1,o=n+s,c=new Uint8Array(o*n).fill(s+1);for(let t=0;t<n;++t)c[t]=t;for(let t=1;t<o;++t)c[t*n]=t;return r(t,e,s,i,c,1,n,""),i})(this._tree,t,e)}get(t){const e=h(this._tree,t);return void 0!==e?e.get(i):void 0}has(t){const e=h(this._tree,t);return void 0!==e&&e.has(i)}keys(){return new n(this,e)}set(t,e){if("string"!=typeof t)throw new Error("key must be a string");this._size=void 0;return d(this._tree,t).set(i,e),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,e){if("string"!=typeof t)throw new Error("key must be a string");this._size=void 0;const s=d(this._tree,t);return s.set(i,e(s.get(i))),this}fetch(t,e){if("string"!=typeof t)throw new Error("key must be a string");this._size=void 0;const s=d(this._tree,t);let n=s.get(i);return void 0===n&&s.set(i,n=e()),n}values(){return new n(this,s)}[Symbol.iterator](){return this.entries()}static from(t){const e=new c;for(const[s,i]of t)e.set(s,i);return e}static fromObject(t){return c.from(Object.entries(t))}}const u=(t,e,s=[])=>{if(0===e.length||null==t)return[t,s];for(const n of t.keys())if(n!==i&&e.startsWith(n))return s.push([t,n]),u(t.get(n),e.slice(n.length),s);return s.push([t,e]),u(void 0,"",s)},h=(t,e)=>{if(0===e.length||null==t)return t;for(const s of t.keys())if(s!==i&&e.startsWith(s))return h(t.get(s),e.slice(s.length))},d=(t,e)=>{const s=e.length;t:for(let n=0;t&&n<s;){for(const o of t.keys())if(o!==i&&e[n]===o[0]){const i=Math.min(s-n,o.length);let r=1;for(;r<i&&e[n+r]===o[r];)++r;const c=t.get(o);if(r===o.length)t=c;else{const s=new Map;s.set(o.slice(r),c),t.set(e.slice(n,n+r),s),t.delete(o),t=s}n+=r;continue t}const o=new Map;return t.set(e.slice(n),o),o}return t},a=(t,e)=>{const[s,n]=u(t,e);if(void 0!==s)if(s.delete(i),0===s.size)l(n);else if(1===s.size){const[t,e]=s.entries().next().value;f(n,t,e)}},l=t=>{if(0===t.length)return;const[e,s]=m(t);if(e.delete(s),0===e.size)l(t.slice(0,-1));else if(1===e.size){const[s,n]=e.entries().next().value;s!==i&&f(t.slice(0,-1),s,n)}},f=(t,e,s)=>{if(0===t.length)return;const[i,n]=m(t);i.set(n+e,s),i.delete(n)},m=t=>t[t.length-1],g="or";class _{constructor(t){if(null==(null==t?void 0:t.fields))throw new Error('MiniSearch: option "fields" must be provided');const e=null==t.autoVacuum||!0===t.autoVacuum?O:t.autoVacuum;this._options=Object.assign(Object.assign(Object.assign({},v),t),{autoVacuum:e,searchOptions:Object.assign(Object.assign({},x),t.searchOptions||{}),autoSuggestOptions:Object.assign(Object.assign({},z),t.autoSuggestOptions||{})}),this._index=new c,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=I,this.addFields(this._options.fields)}add(t){const{extractField:e,tokenize:s,processTerm:i,fields:n,idField:o}=this._options,r=e(t,o);if(null==r)throw new Error(`MiniSearch: document does not have ID field "${o}"`);if(this._idToShortId.has(r))throw new Error(`MiniSearch: duplicate ID ${r}`);const c=this.addDocumentId(r);this.saveStoredFields(c,t);for(const o of n){const n=e(t,o);if(null==n)continue;const r=s(n.toString(),o),u=this._fieldIds[o],h=new Set(r).size;this.addFieldLength(c,u,this._documentCount-1,h);for(const t of r){const e=i(t,o);if(Array.isArray(e))for(const t of e)this.addTerm(u,c,t);else e&&this.addTerm(u,c,e)}}}addAll(t){for(const e of t)this.add(e)}addAllAsync(t,e={}){const{chunkSize:s=10}=e,i={chunk:[],promise:Promise.resolve()},{chunk:n,promise:o}=t.reduce((({chunk:t,promise:e},i,n)=>(t.push(i),(n+1)%s==0?{chunk:[],promise:e.then((()=>new Promise((t=>setTimeout(t,0))))).then((()=>this.addAll(t)))}:{chunk:t,promise:e})),i);return o.then((()=>this.addAll(n)))}remove(t){const{tokenize:e,processTerm:s,extractField:i,fields:n,idField:o}=this._options,r=i(t,o);if(null==r)throw new Error(`MiniSearch: document does not have ID field "${o}"`);const c=this._idToShortId.get(r);if(null==c)throw new Error(`MiniSearch: cannot remove document with ID ${r}: it is not in the index`);for(const o of n){const n=i(t,o);if(null==n)continue;const r=e(n.toString(),o),u=this._fieldIds[o],h=new Set(r).size;this.removeFieldLength(c,u,this._documentCount,h);for(const t of r){const e=s(t,o);if(Array.isArray(e))for(const t of e)this.removeTerm(u,c,t);else e&&this.removeTerm(u,c,e)}}this._storedFields.delete(c),this._documentIds.delete(c),this._idToShortId.delete(r),this._fieldLength.delete(c),this._documentCount-=1}removeAll(t){if(t)for(const e of t)this.remove(e);else{if(arguments.length>0)throw new Error("Expected documents to be present. Omit the argument to remove all documents.");this._index=new c,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldLength=new Map,this._avgFieldLength=[],this._storedFields=new Map,this._nextId=0}}discard(t){const e=this._idToShortId.get(t);if(null==e)throw new Error(`MiniSearch: cannot discard document with ID ${t}: it is not in the index`);this._idToShortId.delete(t),this._documentIds.delete(e),this._storedFields.delete(e),(this._fieldLength.get(e)||[]).forEach(((t,s)=>{this.removeFieldLength(e,s,this._documentCount,t)})),this._fieldLength.delete(e),this._documentCount-=1,this._dirtCount+=1,this.maybeAutoVacuum()}maybeAutoVacuum(){if(!1===this._options.autoVacuum)return;const{minDirtFactor:t,minDirtCount:e,batchSize:s,batchWait:i}=this._options.autoVacuum;this.conditionalVacuum({batchSize:s,batchWait:i},{minDirtCount:e,minDirtFactor:t})}discardAll(t){const e=this._options.autoVacuum;try{this._options.autoVacuum=!1;for(const e of t)this.discard(e)}finally{this._options.autoVacuum=e}this.maybeAutoVacuum()}replace(t){const{idField:e,extractField:s}=this._options,i=s(t,e);this.discard(i),this.add(t)}vacuum(t={}){return this.conditionalVacuum(t)}conditionalVacuum(t,e){return this._currentVacuum?(this._enqueuedVacuumConditions=this._enqueuedVacuumConditions&&e,null!=this._enqueuedVacuum||(this._enqueuedVacuum=this._currentVacuum.then((()=>{const e=this._enqueuedVacuumConditions;return this._enqueuedVacuumConditions=I,this.performVacuuming(t,e)}))),this._enqueuedVacuum):!1===this.vacuumConditionsMet(e)?Promise.resolve():(this._currentVacuum=this.performVacuuming(t),this._currentVacuum)}performVacuuming(e,s){return t(this,void 0,void 0,(function*(){const t=this._dirtCount;if(this.vacuumConditionsMet(s)){const s=e.batchSize||S.batchSize,i=e.batchWait||S.batchWait;let n=1;for(const[t,e]of this._index){for(const[t,s]of e)for(const[i]of s)this._documentIds.has(i)||(s.size<=1?e.delete(t):s.delete(i));0===this._index.get(t).size&&this._index.delete(t),n%s==0&&(yield new Promise((t=>setTimeout(t,i)))),n+=1}this._dirtCount-=t}yield null,this._currentVacuum=this._enqueuedVacuum,this._enqueuedVacuum=null}))}vacuumConditionsMet(t){if(null==t)return!0;let{minDirtCount:e,minDirtFactor:s}=t;return e=e||O.minDirtCount,s=s||O.minDirtFactor,this.dirtCount>=e&&this.dirtFactor>=s}get isVacuuming(){return null!=this._currentVacuum}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}has(t){return this._idToShortId.has(t)}getStoredFields(t){const e=this._idToShortId.get(t);if(null!=e)return this._storedFields.get(e)}search(t,e={}){const{searchOptions:s}=this._options,i=Object.assign(Object.assign({},s),e),n=this.executeQuery(t,e),o=[];for(const[t,{score:e,terms:s,match:r}]of n){const n=s.length||1,c={id:this._documentIds.get(t),score:e*n,terms:Object.keys(r),queryTerms:s,match:r};Object.assign(c,this._storedFields.get(t)),(null==i.filter||i.filter(c))&&o.push(c)}return t===_.wildcard&&null==i.boostDocument||o.sort(k),o}autoSuggest(t,e={}){e=Object.assign(Object.assign({},this._options.autoSuggestOptions),e);const s=new Map;for(const{score:i,terms:n}of this.search(t,e)){const t=n.join(" "),e=s.get(t);null!=e?(e.score+=i,e.count+=1):s.set(t,{score:i,terms:n,count:1})}const i=[];for(const[t,{score:e,terms:n,count:o}]of s)i.push({suggestion:t,terms:n,score:e/o});return i.sort(k),i}get documentCount(){return this._documentCount}get termCount(){return this._index.size}static loadJSON(t,e){if(null==e)throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index");return this.loadJS(JSON.parse(t),e)}static loadJSONAsync(e,s){return t(this,void 0,void 0,(function*(){if(null==s)throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index");return this.loadJSAsync(JSON.parse(e),s)}))}static getDefault(t){if(v.hasOwnProperty(t))return p(v,t);throw new Error(`MiniSearch: unknown option "${t}"`)}static loadJS(t,e){const{index:s,documentIds:i,fieldLength:n,storedFields:o,serializationVersion:r}=t,c=this.instantiateMiniSearch(t,e);c._documentIds=j(i),c._fieldLength=j(n),c._storedFields=j(o);for(const[t,e]of c._documentIds)c._idToShortId.set(e,t);for(const[t,e]of s){const s=new Map;for(const t of Object.keys(e)){let i=e[t];1===r&&(i=i.ds),s.set(parseInt(t,10),j(i))}c._index.set(t,s)}return c}static loadJSAsync(e,s){return t(this,void 0,void 0,(function*(){const{index:t,documentIds:i,fieldLength:n,storedFields:o,serializationVersion:r}=e,c=this.instantiateMiniSearch(e,s);c._documentIds=yield V(i),c._fieldLength=yield V(n),c._storedFields=yield V(o);for(const[t,e]of c._documentIds)c._idToShortId.set(e,t);let u=0;for(const[e,s]of t){const t=new Map;for(const e of Object.keys(s)){let i=s[e];1===r&&(i=i.ds),t.set(parseInt(e,10),yield V(i))}++u%1e3==0&&(yield T(0)),c._index.set(e,t)}return c}))}static instantiateMiniSearch(t,e){const{documentCount:s,nextId:i,fieldIds:n,averageFieldLength:o,dirtCount:r,serializationVersion:u}=t;if(1!==u&&2!==u)throw new Error("MiniSearch: cannot deserialize an index created with an incompatible version");const h=new _(e);return h._documentCount=s,h._nextId=i,h._idToShortId=new Map,h._fieldIds=n,h._avgFieldLength=o,h._dirtCount=r||0,h._index=new c,h}executeQuery(t,e={}){if(t===_.wildcard)return this.executeWildcardQuery(e);if("string"!=typeof t){const s=Object.assign(Object.assign(Object.assign({},e),t),{queries:void 0}),i=t.queries.map((t=>this.executeQuery(t,s)));return this.combineResults(i,s.combineWith)}const{tokenize:s,processTerm:i,searchOptions:n}=this._options,o=Object.assign(Object.assign({tokenize:s,processTerm:i},n),e),{tokenize:r,processTerm:c}=o,u=r(t).flatMap((t=>c(t))).filter((t=>!!t)).map(b(o)).map((t=>this.executeQuerySpec(t,o)));return this.combineResults(u,o.combineWith)}executeQuerySpec(t,e){const s=Object.assign(Object.assign({},this._options.searchOptions),e),i=(s.fields||this._options.fields).reduce(((t,e)=>Object.assign(Object.assign({},t),{[e]:p(s.boost,e)||1})),{}),{boostDocument:n,weights:o,maxFuzzy:r,bm25:c}=s,{fuzzy:u,prefix:h}=Object.assign(Object.assign({},x.weights),o),d=this._index.get(t.term),a=this.termResults(t.term,t.term,1,t.termBoost,d,i,n,c);let l,f;if(t.prefix&&(l=this._index.atPrefix(t.term)),t.fuzzy){const e=!0===t.fuzzy?.2:t.fuzzy,s=e<1?Math.min(r,Math.round(t.term.length*e)):e;s&&(f=this._index.fuzzyGet(t.term,s))}if(l)for(const[e,s]of l){const o=e.length-t.term.length;if(!o)continue;null==f||f.delete(e);const r=h*e.length/(e.length+.3*o);this.termResults(t.term,e,r,t.termBoost,s,i,n,c,a)}if(f)for(const e of f.keys()){const[s,o]=f.get(e);if(!o)continue;const r=u*e.length/(e.length+o);this.termResults(t.term,e,r,t.termBoost,s,i,n,c,a)}return a}executeWildcardQuery(t){const e=new Map,s=Object.assign(Object.assign({},this._options.searchOptions),t);for(const[t,i]of this._documentIds){const n=s.boostDocument?s.boostDocument(i,"",this._storedFields.get(t)):1;e.set(t,{score:n,terms:[],match:{}})}return e}combineResults(t,e=g){if(0===t.length)return new Map;const s=e.toLowerCase(),i=y[s];if(!i)throw new Error(`Invalid combination operator: ${e}`);return t.reduce(i)||new Map}toJSON(){const t=[];for(const[e,s]of this._index){const i={};for(const[t,e]of s)i[t]=Object.fromEntries(e);t.push([e,i])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}termResults(t,e,s,i,n,o,r,c,u=new Map){if(null==n)return u;for(const h of Object.keys(o)){const d=o[h],a=this._fieldIds[h],l=n.get(a);if(null==l)continue;let f=l.size;const m=this._avgFieldLength[a];for(const n of l.keys()){if(!this._documentIds.has(n)){this.removeTerm(a,n,e),f-=1;continue}const o=r?r(this._documentIds.get(n),e,this._storedFields.get(n)):1;if(!o)continue;const g=l.get(n),_=this._fieldLength.get(n)[a],y=s*i*d*o*w(g,f,this._documentCount,_,m,c),b=u.get(n);if(b){b.score+=y,F(b.terms,t);const s=p(b.match,e);s?s.push(h):b.match[e]=[h]}else u.set(n,{score:y,terms:[t],match:{[e]:[h]}})}}return u}addTerm(t,e,s){const i=this._index.fetch(s,C);let n=i.get(t);if(null==n)n=new Map,n.set(e,1),i.set(t,n);else{const t=n.get(e);n.set(e,(t||0)+1)}}removeTerm(t,e,s){if(!this._index.has(s))return void this.warnDocumentChanged(e,t,s);const i=this._index.fetch(s,C),n=i.get(t);null==n||null==n.get(e)?this.warnDocumentChanged(e,t,s):n.get(e)<=1?n.size<=1?i.delete(t):n.delete(e):n.set(e,n.get(e)-1),0===this._index.get(s).size&&this._index.delete(s)}warnDocumentChanged(t,e,s){for(const i of Object.keys(this._fieldIds))if(this._fieldIds[i]===e)return void this._options.logger("warn",`MiniSearch: document with ID ${this._documentIds.get(t)} has changed before removal: term "${s}" was not present in field "${i}". Removing a document after it has changed can corrupt the index!`,"version_conflict")}addDocumentId(t){const e=this._nextId;return this._idToShortId.set(t,e),this._documentIds.set(e,t),this._documentCount+=1,this._nextId+=1,e}addFields(t){for(let e=0;e<t.length;e++)this._fieldIds[t[e]]=e}addFieldLength(t,e,s,i){let n=this._fieldLength.get(t);null==n&&this._fieldLength.set(t,n=[]),n[e]=i;const o=(this._avgFieldLength[e]||0)*s+i;this._avgFieldLength[e]=o/(s+1)}removeFieldLength(t,e,s,i){if(1===s)return void(this._avgFieldLength[e]=0);const n=this._avgFieldLength[e]*s-i;this._avgFieldLength[e]=n/(s-1)}saveStoredFields(t,e){const{storeFields:s,extractField:i}=this._options;if(null==s||0===s.length)return;let n=this._storedFields.get(t);null==n&&this._storedFields.set(t,n={});for(const t of s){const s=i(e,t);void 0!==s&&(n[t]=s)}}}_.wildcard=Symbol("*");const p=(t,e)=>Object.prototype.hasOwnProperty.call(t,e)?t[e]:void 0,y={[g]:(t,e)=>{for(const s of e.keys()){const i=t.get(s);if(null==i)t.set(s,e.get(s));else{const{score:t,terms:n,match:o}=e.get(s);i.score=i.score+t,i.match=Object.assign(i.match,o),M(i.terms,n)}}return t},and:(t,e)=>{const s=new Map;for(const i of e.keys()){const n=t.get(i);if(null==n)continue;const{score:o,terms:r,match:c}=e.get(i);M(n.terms,r),s.set(i,{score:n.score+o,terms:n.terms,match:Object.assign(n.match,c)})}return s},and_not:(t,e)=>{for(const s of e.keys())t.delete(s);return t}},w=(t,e,s,i,n,o)=>{const{k:r,b:c,d:u}=o;return Math.log(1+(s-e+.5)/(e+.5))*(u+t*(r+1)/(t+r*(1-c+c*i/n)))},b=t=>(e,s,i)=>({term:e,fuzzy:"function"==typeof t.fuzzy?t.fuzzy(e,s,i):t.fuzzy||!1,prefix:"function"==typeof t.prefix?t.prefix(e,s,i):!0===t.prefix,termBoost:"function"==typeof t.boostTerm?t.boostTerm(e,s,i):1}),v={idField:"id",extractField:(t,e)=>t[e],tokenize:t=>t.split(L),processTerm:t=>t.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(t,e)=>{"function"==typeof(null===console||void 0===console?void 0:console[t])&&console[t](e)},autoVacuum:!0},x={combineWith:g,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:{k:1.2,b:.7,d:.5}},z={combineWith:"and",prefix:(t,e,s)=>e===s.length-1},S={batchSize:1e3,batchWait:10},I={minDirtFactor:.1,minDirtCount:20},O=Object.assign(Object.assign({},S),I),F=(t,e)=>{t.includes(e)||t.push(e)},M=(t,e)=>{for(const s of e)t.includes(s)||t.push(s)},k=({score:t},{score:e})=>e-t,C=()=>new Map,j=t=>{const e=new Map;for(const s of Object.keys(t))e.set(parseInt(s,10),t[s]);return e},V=e=>t(void 0,void 0,void 0,(function*(){const t=new Map;let s=0;for(const i of Object.keys(e))t.set(parseInt(i,10),e[i]),++s%1e3==0&&(yield T(0));return t})),T=t=>new Promise((e=>setTimeout(e,t))),L=/[\n\r\p{Z}\p{P}]+/u;return _}));
//# sourceMappingURL=/sm/0f05ede3003a11c0848176daa6dae791d4aa6c5c93da9e99ae929f75084ce0d0.map
const baseUrl = "/labor-laws";

const segmenter = Intl.Segmenter && new Intl.Segmenter("zh", { granularity: "word" });
let miniSearch = new MiniSearch({
	fields: ["content"],
	storeFields: ["shorthand", "content", "id"],
	processTerm: (term) => {
		if (!segmenter) return term;
		const tokens = [];
		for (const seg of segmenter.segment(term)) {
			tokens.push(seg.segment);
		}
		return tokens;
	},
});

const indexes = {};
fetch(`${baseUrl}/js/laws.json`)
	.then((res) => res.json())
	.then(function (data) {
		const laws = Object.keys(data);
		miniSearch.addAll(laws.map((law) => {
			return { shorthand: law, ...data[law] };
		}));
		laws.forEach((law)=> {
			const content = [];
			data[law].content.split("\n").forEach((line) => {
				line = line.trim();
				const index = line.search(/\s/);
				if (index > 0) {
					const label = line.slice(0, index);
					if (/条$/.test(label)) {
						content.push([label,line.slice(index).trim()]);
					}
				}
			});
			indexes[law] = content;
		})
	});

function getMatchIndex(elem, match){
	let m = match;
	let matchIndex = -1;
	let numOfRule = -1;
	let label = false;
	const content = indexes[elem.shorthand];
	for (i in content){
		matchIndex = content[i][0].indexOf(m);
		if (matchIndex != -1) {
			numOfRule = i;
			label = true;
			break;
		}
		matchIndex = content[i][1].indexOf(m);
		if (matchIndex != -1) {
			numOfRule = i;
			break;
		}
	}
	if (matchIndex == -1) {
		m = elem.queryTerms[0];
		for (i in content){
			matchIndex = content[i][0].indexOf(m);
			if (matchIndex != -1) {
				numOfRule = i;
				label = true;
				break;
			}
			matchIndex = content[i][1].indexOf(m);
			if (matchIndex != -1) {
				numOfRule = i;
				break;
			}
		}
	}
	return [m, numOfRule, matchIndex, label];
}

function getMatchSnippet(elem, m) {
	const maxLength = 60;
	const [match, numOfRule, matchIndex, isLabel] = getMatchIndex(elem, m);
	let leftText, middleText, rightText;
	if (numOfRule === -1){
		const start = Math.max(0, matchIndex - (maxLength - match.length) / 2);
		const end = Math.min(elem.content.length, matchIndex + match.length + (maxLength - match.length) / 2);
		leftText = elem.content.slice(start, matchIndex);
		middleText = match;
		rightText = elem.content.slice(matchIndex + match.length, end);
	} else {
		if (isLabel){
			const line = indexes[elem.shorthand][numOfRule][1];
			const end = Math.min(line.length, maxLength);
			leftText = line.slice(0, end);
			middleText = "";
			rightText = "";
		} else{
			const line = indexes[elem.shorthand][numOfRule][1];
			const start = Math.max(0, matchIndex - (maxLength - match.length) / 2);
			const end = Math.min(line.length, matchIndex + match.length + (maxLength - match.length) / 2);
			leftText = line.slice(start, matchIndex);
			middleText = match;
			rightText = line.slice(matchIndex + match.length, end);
		}

	}


	const result = document.createElement("a");
	result.className = "search-result";
	result.href = `${baseUrl}/content/${elem.id}.html#${numOfRule}`;

	const label = document.createElement("b");
	label.style.paddingRight = "1rem";
	label.innerHTML = elem.shorthand;
	result.appendChild(label);

	const sublabel = document.createElement("b");
	sublabel.style.paddingRight = "1rem";
	sublabel.innerHTML = indexes[elem.shorthand][numOfRule][0];
	result.appendChild(sublabel);

	const left = document.createElement("span");
	left.innerHTML = leftText
	result.appendChild(left);
	const middle = document.createElement("b");
	middle.innerHTML = middleText;
	result.appendChild(middle);
	const right = document.createElement("span");
	right.innerHTML = rightText;
	result.appendChild(right);

	return result;
}

let searchInput = (val) => {
	const output = document.getElementById("search-results");
	if (val.length >= 2) {
		output.innerHTML = "";
		res = miniSearch.search(val, { prefix: true });
		if (res.length > 0) {
			output.style.display = "block";
			for (elem of res) {
				const snippet = getMatchSnippet(elem, val);
				if (snippet) output.appendChild(snippet);
			}
		} else {
			output.style.display = "none";
			output.innerHTML = "";
		}
	} else {
		output.style.display = "none";
		output.innerHTML = "";
	}
};
</script></body></html>